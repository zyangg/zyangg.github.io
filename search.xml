<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS动画</title>
    <url>/2020/01/20/CSS%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h2 id="第一部分：CSS-Transition"><a href="#第一部分：CSS-Transition" class="headerlink" title="第一部分：CSS Transition"></a>第一部分：CSS Transition</h2><h3 id="1-1-基本用法"><a href="#1-1-基本用法" class="headerlink" title="1.1 基本用法"></a>1.1 基本用法</h3><p>在CSS 3引入Transition（过渡）这个概念之前，CSS是没有时间轴的。也就是说，所有的状态变化，都是即时完成。</p>
<a id="more"></a>

<p> 当鼠标放置于缩略图之上，缩略图会迅速变大 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">450px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">450px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transition的作用在于，指定状态变化所需要的时间。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，图片放大的过程需要1秒。</p>
<p>我们还可以指定transition适用的属性，比如只适用于height。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这样一来，只有height的变化需要1秒实现，其他变化（主要是width）依然瞬间实现。</p>
<h3 id="1-2-transition-delay"><a href="#1-2-transition-delay" class="headerlink" title="1.2 transition-delay"></a>1.2 transition-delay</h3><p>在同一行transition语句中，可以分别指定多个属性。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> height, <span class="number">1s</span> width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是，这样一来，height和width的变化是同时进行的，跟不指定它们没有差别。</p>
<p>我们希望，让height先发生变化，等结束以后，再让width发生变化。实现这一点很容易，就是为width指定一个delay参数。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> height, <span class="number">1s</span> <span class="number">1s</span> width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，width在1秒之后，再开始变化，也就是延迟（delay）1秒。</p>
<p> delay的真正意义在于，它指定了动画发生的顺序，使得多个不同的transition可以连在一起，形成复杂效果。 </p>
<h3 id="1-3-transition-timing-function"><a href="#1-3-transition-timing-function" class="headerlink" title="1.3 transition-timing-function"></a>1.3 transition-timing-function</h3><p>transition的状态变化速度（又称timing function），默认不是匀速的，而是逐渐放慢，这叫做ease。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> ease;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>除了ease以外，其他模式还包括</p>
<blockquote>
<p>（1）linear：匀速</p>
<p>（2）ease-in：加速</p>
<p>（3）ease-out：减速</p>
<p>（4）cubic-bezier函数：自定义速度模式</p>
</blockquote>
<p>最后那个cubic-bezier，可以使用<a href="http://cubic-bezier.com/" target="_blank" rel="noopener">工具网站</a>来定制。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> height <span class="built_in">cubic-bezier</span>(.<span class="number">83</span>,.<span class="number">97</span>,.<span class="number">05</span>,<span class="number">1.44</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码会产生一个最后阶段放大过度、然后回缩的效果。</p>
<h3 id="1-4-transition的各项属性"><a href="#1-4-transition的各项属性" class="headerlink" title="1.4 transition的各项属性"></a>1.4 transition的各项属性</h3><p>transition的完整写法如下。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">1s</span> <span class="number">1s</span> height ease;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这其实是一个简写形式，可以单独定义成各个属性。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">transition-property</span>: height;</span><br><span class="line">    <span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">transition-delay</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">transition-timing-function</span>: ease;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1-5-transition的使用注意"><a href="#1-5-transition的使用注意" class="headerlink" title="1.5 transition的使用注意"></a>1.5 transition的使用注意</h3><p>（1）目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀。</p>
<p>（2）不是所有的CSS属性都支持transition，完整的列表查看<a href="http://oli.jp/2010/css-animatable-properties/" target="_blank" rel="noopener">这里</a>，以及具体的<a href="http://leaverou.github.io/animatable/" target="_blank" rel="noopener">效果</a>。</p>
<p>（3）transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态。比如，height从0px变化到100px，transition可以算出中间状态。但是，transition没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。类似的情况还有，display: none到block，background: url(foo.jpg)到url(bar.jpg)等等。</p>
<h3 id="1-6-transition的局限"><a href="#1-6-transition的局限" class="headerlink" title="1.6 transition的局限"></a>1.6 transition的局限</h3><p>transition的优点在于简单易用，但是它有几个很大的局限。</p>
<p>（1）transition需要事件触发，所以没法在网页加载时自动发生。</p>
<p>（2）transition是一次性的，不能重复发生，除非一再触发。</p>
<p>（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</p>
<p>（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</p>
<p>CSS Animation就是为了解决这些问题而提出的。</p>
<h2 id="第二部分：CSS-Animation"><a href="#第二部分：CSS-Animation" class="headerlink" title="第二部分：CSS Animation"></a>第二部分：CSS Animation</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><p>首先，CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码表示，当鼠标悬停在div元素上时，会产生名为rainbow的动画效果，持续时间为1秒。为此，我们还需要用keyframes关键字，定义rainbow效果。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码表示，rainbow效果一共有三个状态，分别为起始（0%）、中点（50%）和结束（100%）。如果有需要，完全可以插入更多状态。</p>
<p>默认情况下，动画只播放一次。加入infinite关键字，可以让动画无限次播放。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow infinite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>也可以指定动画具体播放的次数，比如3次。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-2-animation-fill-mode"><a href="#2-2-animation-fill-mode" class="headerlink" title="2.2 animation-fill-mode"></a>2.2 animation-fill-mode</h3><p>动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用animation-fill-mode属性。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow forwards;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>forwards表示让动画停留在结束状态。</p>
<p>animation-fill-mode还可以使用下列值。</p>
<blockquote>
<p>（1）none：默认值，回到动画没开始时的状态。</p>
<p>（2）backwards：让动画回到第一帧的状态。</p>
<p>（3）both: 根据animation-direction（见后）轮流应用forwards和backwards规则。</p>
</blockquote>
<h3 id="2-3-animation-direction"><a href="#2-3-animation-direction" class="headerlink" title="2.3 animation-direction"></a>2.3 animation-direction</h3><p>动画循环播放时，每次都是从结束状态跳回到起始状态，再开始播放。animation-direction属性，可以改变这种行为。</p>
<p>下面看一个例子，来说明如何使用animation-direction。假定有一个动画是这样定义的。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  0% &#123; <span class="attribute">background-color</span>: yellow; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">background</span>: blue; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>默认情况是，animation-direction等于normal。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow <span class="number">3</span> normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此外，还可以等于取alternate、reverse、alternate-reverse等值。它们的含义见下图（假定动画连续播放三次）。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/201402/bg2014021401.png" alt="img"></p>
<p>简单说，animation-direction指定了动画播放的方向，最常用的值是normal和reverse。浏览器对其他值的支持情况不佳，应该慎用。</p>
<h3 id="2-4-animation的各项属性"><a href="#2-4-animation的各项属性" class="headerlink" title="2.4 animation的各项属性"></a>2.4 animation的各项属性</h3><p>同transition一样，animation也是一个简写形式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> <span class="number">1s</span> rainbow linear <span class="number">3</span> forwards normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这是一个简写形式，可以分解成各个单独的属性。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation-name</span>: rainbow;</span><br><span class="line">  <span class="attribute">animation-duration</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line">  <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">    <span class="attribute">animation-fill-mode</span>:forwards;</span><br><span class="line">  <span class="attribute">animation-direction</span>: normal;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-5-keyframes的写法"><a href="#2-5-keyframes的写法" class="headerlink" title="2.5 keyframes的写法"></a>2.5 keyframes的写法</h3><p>keyframes关键字用来定义动画的各个状态，它的写法相当自由。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span> &#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange &#125;</span><br><span class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>0%可以用from代表，100%可以用to代表，因此上面的代码等同于下面的形式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">background</span>: <span class="number">#c00</span> &#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果省略某个状态，浏览器会自动推算中间状态，所以下面都是合法的写法。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>甚至，可以把多个状态写在一行。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> pound &#123;</span><br><span class="line">  <span class="selector-tag">from</span>，<span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: none; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.2</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另外一点需要注意的是，浏览器从一个状态向另一个状态过渡，是平滑过渡。steps函数可以实现分步过渡。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow infinite <span class="built_in">steps</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这里有一个非常神奇的<a href="http://dabblet.com/gist/1745856" target="_blank" rel="noopener">例子</a>，可以看到steps函数的用处。</p>
<h3 id="2-6-animation-play-state"><a href="#2-6-animation-play-state" class="headerlink" title="2.6 animation-play-state"></a>2.6 animation-play-state</h3><p>有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态。</p>
<p>如果想让动画保持突然终止时的状态，就要使用animation-play-state属性。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">animation</span>: spin <span class="number">1s</span> linear infinite;</span><br><span class="line">    <span class="attribute">animation-play-state</span>: paused;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码指定，没有鼠标没有悬停时，动画状态是暂停；一旦悬停，动画状态改为继续播放。效果如下。</p>
<h3 id="2-7-浏览器前缀"><a href="#2-7-浏览器前缀" class="headerlink" title="2.7 浏览器前缀"></a>2.7 浏览器前缀</h3><p>目前，IE 10和Firefox（&gt;= 16）支持没有前缀的animation，而chrome不支持，所以必须使用webkit前缀。</p>
<p>也就是说，实际运用中，代码必须写成下面的样子。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-animation</span>: <span class="number">1s</span> rainbow;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> rainbow &#123;</span><br><span class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="参考《阮一峰网络日志》"><a href="#参考《阮一峰网络日志》" class="headerlink" title="参考《阮一峰网络日志》"></a>参考《阮一峰网络日志》</h3>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS定位</title>
    <url>/2020/01/26/CSS%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="一、position-属性的作用"><a href="#一、position-属性的作用" class="headerlink" title="一、position 属性的作用"></a>一、position 属性的作用</h2><p><code>position</code>属性用来指定一个元素在网页上的位置，一共有5种定位方式，即<code>position</code>属性主要有五个值。</p>
<a id="more"></a>

<blockquote>
<ul>
<li><code>static</code></li>
<li><code>relative</code></li>
<li><code>fixed</code></li>
<li><code>absolute</code></li>
<li><code>sticky</code></li>
</ul>
</blockquote>
<h2 id="二、static-属性值"><a href="#二、static-属性值" class="headerlink" title="二、static 属性值"></a>二、static 属性值</h2><p><code>static</code>是<code>position</code>属性的默认值。如果省略<code>position</code>属性，浏览器就认为该元素是<code>static</code>定位。</p>
<p>这时，浏览器会按照源码的顺序，决定每个元素的位置，这称为”正常的页面流”（normal flow）。每个块级元素占据自己的区块（block），元素与元素之间不产生重叠，这个位置就是元素的默认位置。</p>
<p>注意，<code>static</code>定位所导致的元素位置，是浏览器自主决定的，所以这时<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性无效。</p>
<h2 id="三、relative，absolute，fixed"><a href="#三、relative，absolute，fixed" class="headerlink" title="三、relative，absolute，fixed"></a>三、relative，absolute，fixed</h2><p><code>relative</code>、<code>absolute</code>、<code>fixed</code>这三个属性值有一个共同点，都是相对于某个基点的定位，不同之处仅仅在于基点不同。所以，只要理解了它们的基点是什么，就很容易掌握这三个属性值。</p>
<p>这三种定位都不会对其他元素的位置产生影响，因此元素之间可能产生重叠。</p>
<h3 id="3-1-relative-属性值"><a href="#3-1-relative-属性值" class="headerlink" title="3.1 relative 属性值"></a>3.1 relative 属性值</h3><p><code>relative</code>表示，相对于默认位置（即<code>static</code>时的位置）进行偏移，即定位基点是元素的默认位置。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201911/bg2019111721.jpg" alt="img"></p>
<p><img src="https://www.wangbase.com/blogimg/asset/201911/bg2019111722.jpg" alt="img"></p>
<p>它必须搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性一起使用，用来指定偏移的方向和距离。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201911/bg2019111723.jpg" alt="img"></p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>div</code>元素从默认位置向下偏移<code>20px</code>（即距离顶部<code>20px</code>）。</p>
<h3 id="3-2-absolute-属性值"><a href="#3-2-absolute-属性值" class="headerlink" title="3.2 absolute 属性值"></a>3.2 absolute 属性值</h3><p><code>absolute</code>表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。</p>
<p>它有一个重要的限制条件：定位基点（一般是父元素）不能是<code>static</code>定位，否则定位基点就会变成整个网页的根元素<code>html</code>。另外，<code>absolute</code>定位也必须搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性一起使用。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201911/bg2019111801.jpg" alt="img"></p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  HTML 代码如下</span></span><br><span class="line"><span class="comment">  &lt;div id="father"&gt;</span></span><br><span class="line"><span class="comment">    &lt;div id="son"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">  &lt;/div&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-id">#father</span> &#123;</span><br><span class="line">  <span class="attribute">positon</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，父元素是<code>relative</code>定位，子元素是<code>absolute</code>定位，所以子元素的定位基点是父元素，相对于父元素的顶部向下偏移<code>20px</code>。如果父元素是<code>static</code>定位，上例的子元素就是距离网页的顶部向下偏移<code>20px</code>。</p>
<p>注意，<code>absolute</code>定位的元素会被”正常页面流”忽略，即在”正常页面流”中，该元素所占空间为零，周边元素不受影响。</p>
<h3 id="3-3-fixed-属性值"><a href="#3-3-fixed-属性值" class="headerlink" title="3.3 fixed 属性值"></a>3.3 fixed 属性值</h3><p><code>fixed</code>表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201911/bg2019111802.jpg" alt="img"></p>
<p>它如果搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>div</code>元素始终在视口顶部，不随网页滚动而变化。</p>
<h2 id="四、sticky-属性值"><a href="#四、sticky-属性值" class="headerlink" title="四、sticky 属性值"></a>四、sticky 属性值</h2><p><code>sticky</code>跟前面四个属性值都不一样，它会产生动态效果，很像<code>relative</code>和<code>fixed</code>的结合：一些时候是<code>relative</code>定位（定位基点是自身默认位置），另一些时候自动变成<code>fixed</code>定位（定位基点是视口）。</p>
<p>因此，它能够形成”动态固定”的效果。比如，网页的搜索工具栏，初始加载时在自己的默认位置（<code>relative</code>定位）。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201911/bg2019111604.jpg" alt="img"></p>
<p>页面向下滚动时，工具栏变成固定位置，始终停留在页面头部（<code>fixed</code>定位）。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201911/bg2019111605.jpg" alt="img"></p>
<p>等到页面重新向上滚动回到原位，工具栏也会回到默认位置。</p>
<p><code>sticky</code>生效的前提是，必须搭配<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>这四个属性一起使用，不能省略，否则等同于<code>relative</code>定位，不产生”动态固定”的效果。原因是这四个属性用来定义”偏移距离”，浏览器把它当作<code>sticky</code>的生效门槛。</p>
<p>它的具体规则是，当页面滚动，父元素开始脱离视口时（即部分不可见），只要与<code>sticky</code>元素的距离达到生效门槛，<code>relative</code>定位自动切换为<code>fixed</code>定位；等到父元素完全脱离视口时（即完全不可见），<code>fixed</code>定位自动切换回<code>relative</code>定位。</p>
<p>请看下面的示例代码。（注意，除了已被淘汰的 IE 以外，其他浏览器目前都支持<code>sticky</code>。但是，Safari 浏览器需要加上浏览器前缀<code>-webkit-</code>。）</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#toolbar</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: -webkit-sticky; <span class="comment">/* safari 浏览器 */</span></span><br><span class="line">  <span class="attribute">position</span>: sticky; <span class="comment">/* 其他浏览器 */</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，页面向下滚动时，<code>#toolbar</code>的父元素开始脱离视口，一旦视口的顶部与<code>#toolbar</code>的距离小于<code>20px</code>（门槛值），<code>#toolbar</code>就自动变为<code>fixed</code>定位，保持与视口顶部<code>20px</code>的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），<code>#toolbar</code>恢复成<code>relative</code>定位。</p>
<h2 id="五、-sticky-的应用"><a href="#五、-sticky-的应用" class="headerlink" title="五、 sticky 的应用"></a>五、 sticky 的应用</h2><p><code>sticky</code>定位可以实现一些很有用的效果。除了上面提到”动态固定”效果，这里再介绍两个。</p>
<h2 id="5-1-堆叠效果"><a href="#5-1-堆叠效果" class="headerlink" title="5.1 堆叠效果"></a>5.1 堆叠效果</h2><p>堆叠效果（stacking）指的是页面滚动时，下方的元素覆盖上方的元素。下面是一个图片堆叠的例子，下方的图片会随着页面滚动，覆盖上方的图片（查看 <a href="https://jsbin.com/fegiqoquki/edit?html,css,output" target="_blank" rel="noopener">demo</a>）。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201911/bg2019111609.jpg" alt="img"></p>
<p>HTML 代码就是几张图片。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;&lt;img src&#x3D;&quot;pic1.jpg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;&lt;img src&#x3D;&quot;pic2.jpg&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;&lt;img src&#x3D;&quot;pic3.jpg&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>CSS 代码极其简单，只要两行。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它的原理是页面向下滚动时，每张图片都会变成<code>fixed</code>定位，导致后一张图片重叠在前一张图片上面。详细解释可以看<a href="https://dev.to/vinceumo/slide-stacking-effect-using-position-sticky-91f" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="5-2-表格的表头锁定"><a href="#5-2-表格的表头锁定" class="headerlink" title="5.2 表格的表头锁定"></a>5.2 表格的表头锁定</h3><p>大型表格滚动的时候，表头始终固定，也可以用<code>sticky</code>实现（查看 <a href="https://jsbin.com/decemanohe/edit?html,css,output" target="_blank" rel="noopener">demo</a>）。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201911/bg2019111610.jpg" alt="img"></p>
<p>CSS 代码也很简单。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>需要注意的是，<code>sticky</code>必须设在<code>元素上面，不能设在和元素，因为这两个元素没有</code>relative<code>定位，也就无法产生</code>sticky`效果。详细解释可以看<a href="https://css-tricks.com/position-sticky-and-table-headers/" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="参考《阮一峰的网络日志》"><a href="#参考《阮一峰的网络日志》" class="headerlink" title="参考《阮一峰的网络日志》"></a>参考《阮一峰的网络日志》</h3>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS选择器</title>
    <url>/2020/01/15/CSS%E9%80%89%E6%8B%A9%E5%99%A8/</url>
    <content><![CDATA[<p><strong>一、基本选择器</strong></p>
<a id="more"></a>

<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>*****</td>
<td>通用元素选择器，匹配任何元素</td>
</tr>
<tr>
<td>2.</td>
<td><strong>E</strong></td>
<td>标签选择器，匹配所有使用E标签的元素</td>
</tr>
<tr>
<td>3.</td>
<td><strong>.info</strong></td>
<td>class选择器，匹配所有class属性中包含info的元素</td>
</tr>
<tr>
<td>4.</td>
<td><strong>#footer</strong></td>
<td>id选择器，匹配所有id属性等于footer的元素</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>* { margin:0; padding:0; }</p>
<p>p { font-size:2em; }</p>
<p>.info { background:#ff0; }</p>
<p>p.info { background:#ff0; }</p>
<p>p.info.error { color:#900; font-weight:bold; }</p>
<p>#info { background:#ff0; }</p>
<p>p#info { background:#ff0; }</p>
</blockquote>
<p><strong>二、多元素的组合选择器</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>5.</td>
<td>E,F</td>
<td>多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔</td>
</tr>
<tr>
<td>6.</td>
<td>E F</td>
<td>后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔</td>
</tr>
<tr>
<td>7.</td>
<td>E &gt; F</td>
<td>子元素选择器，匹配所有E元素的子元素F</td>
</tr>
<tr>
<td>8.</td>
<td>E + F</td>
<td>毗邻元素选择器，匹配所有紧随E元素之后的同级元素F</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>div p { color:#f00; }</p>
<p>#nav li { display:inline; }</p>
<p>#nav a { font-weight:bold; }</p>
<p>div &gt; strong { color:#f00; }</p>
<p>p + p { color:#f00; }</p>
</blockquote>
<p><strong>三、CSS 2.1 属性选择器</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>9.</td>
<td>E[att]</td>
<td>匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如”[cheacked]”。以下同。）</td>
</tr>
<tr>
<td>10.</td>
<td>E[att=val]</td>
<td>匹配所有att属性等于”val”的E元素</td>
</tr>
<tr>
<td>11.</td>
<td>E[att~=val]</td>
<td>匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素</td>
</tr>
<tr>
<td>12.</td>
<td>E[att|=val]</td>
<td>匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>p[title] { color:#f00; }</p>
<p>div[class=error] { color:#f00; }</p>
<p>td[headers~=col1] { color:#f00; }</p>
<p>p[lang|=en] { color:#f00; }</p>
<p>blockquote[class=quote][cite] { color:#f00; }</p>
</blockquote>
<p><strong>四、CSS 2.1中的伪类</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>13.</td>
<td>E:first-child</td>
<td>匹配父元素的第一个子元素</td>
</tr>
<tr>
<td>14.</td>
<td>E:link</td>
<td>匹配所有未被点击的链接</td>
</tr>
<tr>
<td>15.</td>
<td>E:visited</td>
<td>匹配所有已被点击的链接</td>
</tr>
<tr>
<td>16.</td>
<td>E:active</td>
<td>匹配鼠标已经其上按下、还没有释放的E元素</td>
</tr>
<tr>
<td>17.</td>
<td>E:hover</td>
<td>匹配鼠标悬停其上的E元素</td>
</tr>
<tr>
<td>18.</td>
<td>E:focus</td>
<td>匹配获得当前焦点的E元素</td>
</tr>
<tr>
<td>19.</td>
<td>E:lang(c)</td>
<td>匹配lang属性等于c的E元素</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>p:first-child { font-style:italic; }</p>
<p>input[type=text]:focus { color:#000; background:#ffe; }</p>
<p>input[type=text]:focus:hover { background:#fff; }</p>
<p>q:lang(sv) { quotes: “\201D” “\201D” “\2019” “\2019”; }</p>
</blockquote>
<p><strong>五、 CSS 2.1中的伪元素</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>20.</td>
<td>E:first-line</td>
<td>匹配E元素的第一行</td>
</tr>
<tr>
<td>21.</td>
<td>E:first-letter</td>
<td>匹配E元素的第一个字母</td>
</tr>
<tr>
<td>22.</td>
<td>E:before</td>
<td>在E元素之前插入生成的内容</td>
</tr>
<tr>
<td>23.</td>
<td>E:after</td>
<td>在E元素之后插入生成的内容</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>p:first-line { font-weight:bold; color;#600; }</p>
<p>.preamble:first-letter { font-size:1.5em; font-weight:bold; }</p>
<p>.cbb:before { content:””; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; }</p>
<p>a:link:after { content: “ (“ attr(href) “) “; }</p>
</blockquote>
<p><strong>六、CSS 3的同级元素通用选择器</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>24.</td>
<td>E ~ F</td>
<td>匹配任何在E元素之后的同级F元素</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>p ~ ul { background:#ff0; }</p>
</blockquote>
<p><strong>七、CSS 3 属性选择器</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>25.</td>
<td>E[att^=”val”]</td>
<td>属性att的值以”val”开头的元素</td>
</tr>
<tr>
<td>26.</td>
<td>E[att$=”val”]</td>
<td>属性att的值以”val”结尾的元素</td>
</tr>
<tr>
<td>27.</td>
<td>E[att*=”val”]</td>
<td>属性att的值包含”val”字符串的元素</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>div[id^=”nav”] { background:#ff0; }</p>
</blockquote>
<p><strong>八、CSS 3中与用户界面有关的伪类</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>28.</td>
<td>E:enabled</td>
<td>匹配表单中激活的元素</td>
</tr>
<tr>
<td>29.</td>
<td>E:disabled</td>
<td>匹配表单中禁用的元素</td>
</tr>
<tr>
<td>30.</td>
<td>E:checked</td>
<td>匹配表单中被选中的radio（单选框）或checkbox（复选框）元素</td>
</tr>
<tr>
<td>31.</td>
<td>E::selection</td>
<td>匹配用户当前选中的元素</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>input[type=”text”]:disabled { background:#ddd; }</p>
</blockquote>
<p><strong>九、CSS 3中的结构性伪类</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>32.</td>
<td>E:root</td>
<td>匹配文档的根元素，对于HTML文档，就是HTML元素</td>
</tr>
<tr>
<td>33.</td>
<td>E:nth-child(n)</td>
<td>匹配其父元素的第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>34.</td>
<td>E:nth-last-child(n)</td>
<td>匹配其父元素的倒数第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>35.</td>
<td>E:nth-of-type(n)</td>
<td>与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>36.</td>
<td>E:nth-last-of-type(n)</td>
<td>与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>37.</td>
<td>E:last-child</td>
<td>匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>
</tr>
<tr>
<td>38.</td>
<td>E:first-of-type</td>
<td>匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>
</tr>
<tr>
<td>39.</td>
<td>E:last-of-type</td>
<td>匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>
</tr>
<tr>
<td>40.</td>
<td>E:only-child</td>
<td>匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>
</tr>
<tr>
<td>41.</td>
<td>E:only-of-type</td>
<td>匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>
</tr>
<tr>
<td>42.</td>
<td>E:empty</td>
<td>匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>p:nth-child(3) { color:#f00; }</p>
<p>p:nth-child(odd) { color:#f00; }</p>
<p>p:nth-child(even) { color:#f00; }</p>
<p>p:nth-child(3n+0) { color:#f00; }</p>
<p>p:nth-child(3n) { color:#f00; }</p>
<p>tr:nth-child(2n+11) { background:#ff0; }</p>
<p>tr:nth-last-child(2) { background:#ff0; }</p>
<p>p:last-child { background:#ff0; }</p>
<p>p:only-child { background:#ff0; }</p>
<p>p:empty { background:#ff0; }</p>
</blockquote>
<p><strong>十、CSS 3的反选伪类</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>43.</td>
<td>E:not(s)</td>
<td>匹配不符合当前选择器的任何元素</td>
</tr>
</tbody></table>
<p>实例：</p>
<blockquote>
<p>:not(p) { border:1px solid #ccc; }</p>
</blockquote>
<p><strong>十一、CSS 3中的 :target 伪类</strong></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>44.</td>
<td>E:target</td>
<td>匹配文档中特定”id”点击后的效果</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的promise</title>
    <url>/2020/02/23/ES6%E7%9A%84promise/</url>
    <content><![CDATA[<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h5 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1.基本定义"></a>1.基本定义</h5><p>  Promise是<strong>异步编程</strong>的一种解决方案。它是一个<strong>类</strong>，可以通过new的方式创建一个对象。</p>
<a id="more"></a>

<h5 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h5><p>  正如它的基本定义一样，一般用在异步请求的场合，并且会将请求数据的模块放在一个地方，处理数据的模块放在另外一个地方，就不会像之前回调函数一样，将请求url数据和处理data1数据都放在同一个地方<br> <strong>第一：promise用来处理异步编程</strong><br> <strong>第二：promise将请求模块和处理模块分开</strong></p>
<h5 id="3-使用语法"><a href="#3-使用语法" class="headerlink" title="3.使用语法"></a>3.使用语法</h5><p><strong>① 使用new创建</strong><br>  我们知道promise是一个类，所以我们可以通过new的方式来创建promise，并且<strong>创建的promise是一个函数</strong><br> <strong>② 传入参数</strong><br>  当我们通过new方式创建promise函数时，就会被要求传入两个参数：<strong>resolve和reject</strong>，而这两个参数<strong>本身又是一个函数</strong><br> <strong>③ then函数</strong><br>  我们创建完promise之后，将有关的请求数据放在promise内部，然后将处理数据放在then函数，并且当用户执行了resolve函数就会调用then函数。更神奇的是，<strong>then本身又是一个函数</strong>。<br> 有点抽象，我们看看下面的例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">setTimeout(&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello,vue'</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>  以setTimeout为异步事件，经过一秒中后就打印“hello，vue”语句，我们可以假定 setTimeout 函数是向服务器发送的请求，而console.log(‘hello,vue’)是对服务器发送请求的处理，下面使用promise封装过程如下：<br> <strong>第一：声明promise，并将异步事件全部丢到promise函数中</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    setTimeout(&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello,vue'</span>);</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  上述代码中，创建了promise函数，两个参数resolve和reject由于本身又是一个函数，所以在这里使用<strong>箭头函数</strong>来声明，然后将异步事件全部丢进promise函数内部中。<br> <strong>第二：封装数据</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello,vue'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  上述代码中，setTimeout函数看作请求，该请求是经过1秒后执行打印语句，将请求放在了promie内部，然后打印语句看作是对请求的处理，放在了then函数中。执行顺序如下：<strong>首先进入到promise内部，经过一秒中后执行resolve函数，该函数就会回调then函数，执行then函数内部的打印语句。</strong></p>
<p>Promise中还有另外两个函数 reject 和catch。 reject的用法和resolve的用法是一样的，不一样的是，当请求某些数据失败的时候就会执行reject函数，该函数就会回调catch函数，具体代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line">            reject()</span><br><span class="line">        &#125;,1000)</span><br><span class="line"><span class="javascript">    &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'error'</span>)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="链式调用"><a href="#链式调用" class="headerlink" title=" 链式调用"></a> 链式调用</h2><h5 id="1-链式调用1"><a href="#1-链式调用1" class="headerlink" title="1.链式调用1"></a>1.链式调用1</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello,vue'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    resolve()</span><br><span class="line">                &#125;,<span class="number">1000</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hello,java'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                        resolve()</span><br><span class="line">                    &#125;,<span class="number">1000</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'hello,JavaScript'</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-链式调用2"><a href="#2-链式调用2" class="headerlink" title="2.链式调用2"></a>2.链式调用2</h5><p><strong>① 版本一</strong><br>  现在我们有一个需求，当向网络请求数据得到的结果是aaa时，进行两步操作，<strong>第一步是自身对别的业务逻辑进行处理，第二是对拿到的结果aaa进行处理</strong>，然后不断循环该过程，我们通过链式调用来达到这种目的，具体代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">                    resolve(<span class="string">'aaa'</span>)</span></span><br><span class="line">                &#125;,1000)</span><br><span class="line"><span class="javascript">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 1.自己处理别的业务的代码</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(res,<span class="string">'第一次自己处理别的业务的代码'</span>)</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 2.对拿到的结果进行处理</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">                    resolve(res +<span class="string">'111'</span>)</span></span><br><span class="line">                &#125;)</span><br><span class="line"><span class="javascript">            &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(res,<span class="string">'第二次自己处理别的业务的代码'</span>)</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">                    resolve(res +<span class="string">'222'</span>)</span></span><br><span class="line">                &#125;)</span><br><span class="line"><span class="javascript">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(res,<span class="string">'第三次自己处理别的业务的代码'</span>)</span></span><br><span class="line">            &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p> <img src="https://img-blog.csdnimg.cn/20200516220840405.png" alt="img"> </p>
<p>  上述代码中，之所以要将对结果的处理再放到一个Promise中，是因为不想和自己处理别的业务逻辑的代码放在一块，不然容易分辨不清那个模块处理什么内容。<strong>② 版本二</strong> 上述的代码还可以进行简化，简化版如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    resolve(<span class="string">'aaa'</span>)</span><br><span class="line">                &#125;,<span class="number">1000</span>)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res,<span class="string">'第一次自己处理别的业务的代码'</span>)</span><br><span class="line">                <span class="keyword">return</span>  <span class="built_in">Promise</span>.resolve(res +<span class="string">'111'</span>)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res,<span class="string">'第二次自己处理别的业务的代码'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res +<span class="string">'222'</span>)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res,<span class="string">'第三次自己处理别的业务的代码'</span>)   </span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<p>  只是将上述代码中对结果处理的Promise进行了简化，不需要通过new Promise 的方式来获取resolve函数，而是直接通过Promise.resolve(）的方式来获取。<br> <strong>③ 版本三</strong><br> 另外还有一个更加简化版的，具体代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    resolve(<span class="string">'aaa'</span>)</span><br><span class="line">                &#125;,<span class="number">1000</span>)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res,<span class="string">'第一次自己处理别的业务的代码'</span>)</span><br><span class="line">                <span class="keyword">return</span>  res +<span class="string">'111'</span></span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res,<span class="string">'第二次自己处理别的业务的代码'</span>)</span><br><span class="line">                <span class="keyword">return</span> res +<span class="string">'222'</span></span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res,<span class="string">'第三次自己处理别的业务的代码'</span>)   </span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<p>  这次的代码是直接将Promise.resolve都省略了，让他们内部自己运行Promise.resolve（）。三个简化版的结构是一样的，这里就不展示出来了。<br>  另外还有一个需要注意的问题，<strong>如果是调用了reject函数，会直接跳转去执行catch函数，中间的代码就不会被执行了</strong>，比如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                    resolve(<span class="string">'aaa'</span>)</span><br><span class="line">                &#125;,<span class="number">1000</span>)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res,<span class="string">'第一次自己处理别的业务的代码'</span>)</span><br><span class="line">                <span class="keyword">return</span>  <span class="built_in">Promise</span>.reject(res +<span class="string">'111'</span>)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res,<span class="string">'第二次自己处理别的业务的代码'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res +<span class="string">'222'</span>)</span><br><span class="line">            &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res,<span class="string">'第三次自己处理别的业务的代码'</span>)   </span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'error'</span>)    </span><br><span class="line">            &#125;)</span><br></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20200516220850446.png" alt="img"> </p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6数组</title>
    <url>/2020/02/22/ES6%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h2 id="数组扩展方法"><a href="#数组扩展方法" class="headerlink" title="数组扩展方法"></a>数组扩展方法</h2><p>1.ES6数组的各种方法</p>
<p>在ES5的基础上ES6有了许多新的操作数组的方法，使得我们操作数组更加遍历</p>
<a id="more"></a>

<p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzRFMDhDNjA0Mzg3RjQ4QTM5QzJGMUI0QUFFQ0JBQzA3Lzk2Mzg?x-oss-process=image/format,png" alt="img"> </p>
<p>2.forEach（）函数</p>
<p>①数组名.forEach（function（数组中一个元素的值）{对这个值进行处理….}）</p>
<p>②数组名.forEach（test）test为方法名，不用加（），把函数引用传进去</p>
<p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzJGRTU3RjgzNjM0QzRFQTVBMkU3N0NEQUI5NTcxQUEyLzk2NTE?x-oss-process=image/format,png" alt="img"> </p>
<p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlL0Y5RkUwMzUzQUQ4RDRFREFBOUE3MkU0NUE5NUM2MjNGLzk2NTQ?x-oss-process=image/format,png" alt="img"> </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzEwRkM3NERDNTkxOTRCNjY5RkE1Q0UwMUZEOERGMDFCLzk2NTY?x-oss-process=image/format,png" alt="img"> </p>
<p>③利用函数引用这种方式的话，会自己把每个值传进去，不需要用（）传进去</p>
<p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzRGMTg4M0I4MUJDOTQ5RjI4MDc4MjU3RTkyQzFBRjQ1Lzk2NTg?x-oss-process=image/format,png" alt="img"> </p>
<p>3.map（）方法</p>
<p>①map（）方法一定要有一个返回值，没有返回值的话就会返回一个undefined</p>
<p>②map（）方法的返回值是一个数组</p>
<p>③应用场景：要返回一个要利用原数组经过运算后的数组，或者是在一个对象数组中要拿到某一个属性，并且返回一个新数组的情况</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlL0MwNzc3QUE5OEIwMjRDRDA5NDZFODRDRTExODJCMzcyLzk2NzI?x-oss-process=image/format,png" alt="img"> </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlL0U4N0Y0MzIxMzU3NjQyMjdBREMzREE5MzNEN0FBRjZBLzk2NzQ?x-oss-process=image/format,png" alt="img"> </p>
<p>4.filter（）函数</p>
<p>①filter可以返回一个新数组，也可以直接改变原数组</p>
<p>①应用场景：</p>
<p>1)已知对象数组，要把对象数组中一些符合要求的对象重新组成一个数组</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzdEMjZCM0FDOEU5NDQzQkY5RTY1NUMxNzgyMEY1OTE1Lzk2OTU?x-oss-process=image/format,png" alt="img"> </p>
<p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlL0ExQjQ2QjdGQjJFMjQ1NjNBOUZDMDU1OUY3MzJFRjlCLzk2ODY?x-oss-process=image/format,png" alt="img"> </p>
<p>2）筛选出符合多个条件的对象数组中的一些元素，组成新数组或者是直接覆盖原数组</p>
<p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzEyQzQzMjMzRjE5QjQ1Mzc5QTdBRkMxQTg2N0ZCNjhDLzk2OTc?x-oss-process=image/format,png" alt="img"> </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzdDMkNEQjExMEMyMTQ0NTQ4ODUxNERGOUVCQkQ0MTQ4Lzk2OTk?x-oss-process=image/format,png" alt="img"> </p>
<p>3）有两个数组（A，B），根据A中的ID值，过滤掉B数组中不符合的数据</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzE1MUE0Q0FFMUI4MDRBODZCMkE4MzVENzY3NTIwNjYyLzk3MDU?x-oss-process=image/format,png" alt="img"> </p>
<p>5.find（）方法</p>
<p>①find（）方法只会找到第一个符合的，找到之后就会直接返回，就算下面还有符合要求的，也不会再找下去</p>
<p>②应用场景</p>
<p>1)在对象数组中，找到符合要求的对象,只能找到第一个符合要求的</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlL0I1RUZBRjVFMjUyMjQ1MUJCQjU2QjkwQjJENEIxNjJELzk3MTk?x-oss-process=image/format,png" alt="img"> </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzcyOUY5QzRFN0MyNTREMEQ4RTI3NjRBRDdCMTFDMDNGLzk3MTM?x-oss-process=image/format,png" alt="img"> </p>
<p>2)两个对象数组，找A数组中有B数组的ID的元素</p>
<p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzY1MUEyQjdCNURFRjRGRDk5ODk5QzdGRDRERTM0MjkyLzk3MjU?x-oss-process=image/format,png" alt="img"> </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlL0JENDIyNkJGREIzMTRFRDg5MTFDQzE4RUQyQzgxODYwLzk3Mjc?x-oss-process=image/format,png" alt="img"> </p>
<p>3）开发应用环境：博客列表，点击博客列表，根据博客列表的URL的数组，用find找到对应的Id，然后找到对应的列表的详情页的URL，并进行展示</p>
<p>6.some（）和every（）方法</p>
<p>①some()方法只要有一个满足就行，every（）方法要所有的满足才可以，即some（）：一真即真，every（）：一假即假，跟逻辑运算符差不多</p>
<p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzRBRDYxQUY3Q0U2QTRFMDc5QjQ3Q0UzQkYyNEQzQzI5Lzk3MzY?x-oss-process=image/format,png" alt="img"> </p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzlFOEVFNjNBREM4NTQyNkJBOEMyODhDQjA0RDMyQTY2Lzk3NDI?x-oss-process=image/format,png" alt="img"> </p>
<p>②运用场景</p>
<p>1)如果所有的操作系统都大于16位，则该程序可用，否则即为不可用</p>
<p>//some只要有一个大于，它就不会再往下找，直接返回true，因为相当于 || （逻辑或运算符）</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzEwOTA0MDZEQjlGNjQxNzRBRUYzQUVBOEZENEY5RUJBLzk3NTU?x-oss-process=image/format,png" alt="img"> </p>
<p>//every()相当于&amp;&amp;，找到第一个错的就直接返回false，不再往下找</p>
<p>  <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzU0MkNFQjgxQjY0ODREQUJBMTFFNEUzN0Q1MTM2RDQ3Lzk3NjE?x-oss-process=image/format,png" alt="img"> </p>
<p>7.reduce（）方法</p>
<p>①reduce（function（sum,number）{…},0）要有两个参数，第一个参数一定要初始化</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzE3OUU5RTM5NkY0QzQ5NTBBMzM5RUUyMkUwNEFGMzkwLzk3NzA?x-oss-process=image/format,png" alt="img"> </p>
<p>②应用场景</p>
<p>1)代替map做一些简单的运算</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlL0JFQzM4M0YwRUVDMDRCQkFCQUE1MjQ4MkIyRjIwMjAxLzk3Nzk?x-oss-process=image/format,png" alt="img"> </p>
<p>2）将一个对象数组中的某些属性的值抽出来，组成一个新的数组</p>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9ub3RlLnlvdWRhby5jb20veXdzL3B1YmxpYy9yZXNvdXJjZS84M2FhMWYxNzM3MjU4YzJlZWM1NzUwNmQyNDYxODJkNy94bWxub3RlLzc0RkE5MTBDQzFEMDQ3RjZBN0YwQzg1RTcwQUFGMTc1Lzk3ODM?x-oss-process=image/format,png" alt="img"> </p>
<h2 id="String-的扩展方法"><a href="#String-的扩展方法" class="headerlink" title="String 的扩展方法"></a>String 的扩展方法</h2><h4 id="模板字符串（★★★）"><a href="#模板字符串（★★★）" class="headerlink" title="模板字符串（★★★）"></a>模板字符串（★★★）</h4><p>ES6新增的创建字符串的方式，使用反引号定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">`zhangsan`</span>;</span><br></pre></td></tr></table></figure>

<h5 id="模板字符串中可以解析变量"><a href="#模板字符串中可以解析变量" class="headerlink" title="模板字符串中可以解析变量"></a>模板字符串中可以解析变量</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'张三'</span>; </span><br><span class="line"><span class="keyword">let</span> sayHello = <span class="string">`hello,my name is <span class="subst">$&#123;name&#125;</span>`</span>; <span class="comment">// hello, my name is zhangsan</span></span><br></pre></td></tr></table></figure>

<h5 id="模板字符串中可以换行"><a href="#模板字符串中可以换行" class="headerlink" title="模板字符串中可以换行"></a>模板字符串中可以换行</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = &#123; </span><br><span class="line">    name: <span class="string">'zhangsan'</span>, </span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    sex: <span class="string">'男'</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> html = <span class="string">` &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.name&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.age&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.sex&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt; `</span>;</span><br></pre></td></tr></table></figure>

<h5 id="在模板字符串中可以调用函数"><a href="#在模板字符串中可以调用函数" class="headerlink" title="在模板字符串中可以调用函数"></a>在模板字符串中可以调用函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'哈哈哈哈 追不到我吧 我就是这么强大'</span>;</span><br><span class="line"> &#125;; </span><br><span class="line"> <span class="keyword">let</span> greet = <span class="string">`<span class="subst">$&#123;sayHello()&#125;</span> 哈哈哈哈`</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(greet); <span class="comment">// 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</span></span><br></pre></td></tr></table></figure>

<h4 id="实例方法：startsWith-和-endsWith"><a href="#实例方法：startsWith-和-endsWith" class="headerlink" title="实例方法：startsWith() 和 endsWith()"></a>实例方法：startsWith() 和 endsWith()</h4><ul>
<li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</li>
<li>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'Hello world!'</span>;</span><br><span class="line">str.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true </span></span><br><span class="line">str.endsWith(<span class="string">'!'</span>)       <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h4><p>repeat方法表示将原字符串重复n次，返回一个新字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>)      <span class="comment">// "xxx" </span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>)  <span class="comment">// "hellohello"</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6解构赋值和剩余参数</title>
    <url>/2020/02/20/ES6%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="解构赋值（★★★）"><a href="#解构赋值（★★★）" class="headerlink" title="解构赋值（★★★）"></a>解构赋值（★★★）</h3><p>ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构</p>
<a id="more"></a>

<h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> <span class="built_in">console</span>.log(a)<span class="comment">//1</span></span><br><span class="line"> <span class="built_in">console</span>.log(b)<span class="comment">//2</span></span><br><span class="line"> <span class="built_in">console</span>.log(c)<span class="comment">//3</span></span><br><span class="line"><span class="comment">//如果解构不成功，变量的值为undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">'zhangsan'</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;; </span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 'zhangsan' </span></span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>: myName, <span class="attr">age</span>: myAge&#125; = person; <span class="comment">// myName myAge 属于别名</span></span><br><span class="line"><span class="built_in">console</span>.log(myName); <span class="comment">// 'zhangsan' </span></span><br><span class="line"><span class="built_in">console</span>.log(myAge); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>解构赋值就是把数据结构分解，然后给变量进行赋值</li>
<li>如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined</li>
<li>数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开</li>
<li>利用解构赋值能够让我们方便的去取对象中的属性跟方法</li>
</ul>
<h3 id="剩余参数（★★）"><a href="#剩余参数（★★）" class="headerlink" title="剩余参数（★★）"></a>剩余参数（★★）</h3><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(first); <span class="comment">// 10</span></span><br><span class="line">     <span class="built_in">console</span>.log(args); <span class="comment">// [20, 30] </span></span><br><span class="line"> &#125;</span><br><span class="line"> sum(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h4 id="剩余参数和解构配合使用"><a href="#剩余参数和解构配合使用" class="headerlink" title="剩余参数和解构配合使用"></a>剩余参数和解构配合使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> students = [<span class="string">'wangwu'</span>, <span class="string">'zhangsan'</span>, <span class="string">'lisi'</span>];</span><br><span class="line"><span class="keyword">let</span> [s1, ...s2] = students; </span><br><span class="line"><span class="built_in">console</span>.log(s1);  <span class="comment">// 'wangwu' </span></span><br><span class="line"><span class="built_in">console</span>.log(s2);  <span class="comment">// ['zhangsan', 'lisi']</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h4><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">...ary  <span class="comment">// 1, 2, 3</span></span><br><span class="line"><span class="built_in">console</span>.log(...ary);    <span class="comment">// 1 2 3,相当于下面的代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h5 id="扩展运算符可以应用于合并数组"><a href="#扩展运算符可以应用于合并数组" class="headerlink" title="扩展运算符可以应用于合并数组"></a>扩展运算符可以应用于合并数组</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一 </span></span><br><span class="line"> <span class="keyword">let</span> ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> <span class="keyword">let</span> ary2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"> <span class="keyword">let</span> ary3 = [...ary1, ...ary2];</span><br><span class="line"> <span class="comment">// 方法二 </span></span><br><span class="line"> ary1.push(...ary2);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6语法</title>
    <url>/2020/02/20/ES6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="ES6新增语法"><a href="#ES6新增语法" class="headerlink" title="ES6新增语法"></a>ES6新增语法</h2><h3 id="let（★★★）"><a href="#let（★★★）" class="headerlink" title="let（★★★）"></a>let（★★★）</h3><p>ES6中新增了用于声明变量的关键字</p>
<a id="more"></a>

<h4 id="let声明的变量只在所处于的块级有效"><a href="#let声明的变量只在所处于的块级有效" class="headerlink" title="let声明的变量只在所处于的块级有效"></a>let声明的变量只在所处于的块级有效</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a is not defined </span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>利用let声明的变量会绑定在这个块级作用域，不会受外界的影响</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    tmp = <span class="string">'abc'</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20200516212415715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzOTk4Nw==,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p><strong>经典面试题图解：</strong>此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20200516212415757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkzOTk4Nw==,size_16,color_FFFFFF,t_70" alt="img"> </p>
<p><strong>经典面试题图解：</strong>此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>let关键字就是用来声明变量的</li>
<li>使用let关键字声明的变量具有块级作用域</li>
<li>在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的</li>
<li>防止循环变量变成全局变量</li>
<li>使用let关键字声明的变量没有变量提升</li>
<li>使用let关键字声明的变量具有暂时性死区特性</li>
</ul>
<h3 id="const（★★★）"><a href="#const（★★★）" class="headerlink" title="const（★★★）"></a>const（★★★）</h3><p>声明常量，常量就是值（内存地址）不能变化的量</p>
<h4 id="具有块级作用域"><a href="#具有块级作用域" class="headerlink" title="具有块级作用域"></a>具有块级作用域</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">     <span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="声明常量时必须赋值"><a href="#声明常量时必须赋值" class="headerlink" title="声明常量时必须赋值"></a>声明常量时必须赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI; <span class="comment">// Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>

<h4 id="常量赋值后，值不能修改"><a href="#常量赋值后，值不能修改" class="headerlink" title="常量赋值后，值不能修改"></a>常量赋值后，值不能修改</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">100</span>; <span class="comment">// Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ary = [<span class="number">100</span>, <span class="number">200</span>];</span><br><span class="line">ary[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br><span class="line">ary[<span class="number">1</span>] = <span class="string">'b'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ary); <span class="comment">// ['a', 'b']; </span></span><br><span class="line">ary = [<span class="string">'a'</span>, <span class="string">'b'</span>]; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul>
<li>const声明的变量是一个常量</li>
<li>既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值</li>
<li>声明 const时候必须要给定值</li>
</ul>
<h3 id="let、const、var-的区别"><a href="#let、const、var-的区别" class="headerlink" title="let、const、var 的区别"></a>let、const、var 的区别</h3><ul>
<li><p>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象</p>
</li>
<li><p>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升</p>
</li>
<li><p>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值</p>
<p><img src="https://img-blog.csdnimg.cn/20200516212415774.png" alt="img"> </p>
</li>
</ul>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Flex布局</title>
    <url>/2020/01/27/Flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 Flex 布局。</p>
<a id="more"></a>

<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>行内元素也可以使用 Flex 布局。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p>
<h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="img"></p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p>
<h2 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h2><p>以下6个属性设置在容器上。</p>
<blockquote>
<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</blockquote>
<h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" alt="img"></p>
<p>它可能有4个值。</p>
<blockquote>
<ul>
<li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li>
<li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li>
<li><code>column</code>：主轴为垂直方向，起点在上沿。</li>
<li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li>
</ul>
</blockquote>
<h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="img"></p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它可能取三个值。</p>
<p>（1）<code>nowrap</code>（默认）：不换行。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="img"></p>
<p>（2）<code>wrap</code>：换行，第一行在上方。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="img"></p>
<p>（3）<code>wrap-reverse</code>：换行，第一行在下方。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="img"></p>
<h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="img"></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<blockquote>
<ul>
<li><code>flex-start</code>（默认值）：左对齐</li>
<li><code>flex-end</code>：右对齐</li>
<li><code>center</code>： 居中</li>
<li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li>
<li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</blockquote>
<h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="img"></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：交叉轴的起点对齐。</li>
<li><code>flex-end</code>：交叉轴的终点对齐。</li>
<li><code>center</code>：交叉轴的中点对齐。</li>
<li><code>baseline</code>: 项目的第一行文字的基线对齐。</li>
<li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</blockquote>
<h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="img"></p>
<p>该属性可能取6个值。</p>
<blockquote>
<ul>
<li><code>flex-start</code>：与交叉轴的起点对齐。</li>
<li><code>flex-end</code>：与交叉轴的终点对齐。</li>
<li><code>center</code>：与交叉轴的中点对齐。</li>
<li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li>
</ul>
</blockquote>
<h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>
<blockquote>
<ul>
<li><code>order</code></li>
<li><code>flex-grow</code></li>
<li><code>flex-shrink</code></li>
<li><code>flex-basis</code></li>
<li><code>flex</code></li>
<li><code>align-self</code></li>
</ul>
</blockquote>
<h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="img"></p>
<h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="img"></p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="img"></p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p>
<h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="img"></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<h3 id="五、圣杯布局"><a href="#五、圣杯布局" class="headerlink" title="五、圣杯布局"></a>五、圣杯布局</h3><p><a href="https://en.wikipedia.org/wiki/Holy_Grail_(web_design)" target="_blank" rel="noopener">圣杯布局</a>（Holy Grail Layout）指的是一种最常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071323.png" alt="img"></p>
<p>HTML代码如下。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body class&#x3D;&quot;HolyGrail&quot;&gt;</span><br><span class="line">  &lt;header&gt;...&lt;&#x2F;header&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;HolyGrail-body&quot;&gt;</span><br><span class="line">    &lt;main class&#x3D;&quot;HolyGrail-content&quot;&gt;...&lt;&#x2F;main&gt;</span><br><span class="line">    &lt;nav class&#x3D;&quot;HolyGrail-nav&quot;&gt;...&lt;&#x2F;nav&gt;</span><br><span class="line">    &lt;aside class&#x3D;&quot;HolyGrail-ads&quot;&gt;...&lt;&#x2F;aside&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;footer&gt;...&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>CSS代码如下。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.HolyGrail</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.HolyGrail-body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.HolyGrail-content</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.HolyGrail-nav</span>, <span class="selector-class">.HolyGrail-ads</span> &#123;</span><br><span class="line">  <span class="comment">/* 两个边栏的宽度设为12em */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">12em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.HolyGrail-nav</span> &#123;</span><br><span class="line">  <span class="comment">/* 导航放到最左边 */</span></span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果是小屏幕，躯干的三栏自动变为垂直叠加。</p>
<blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.HolyGrail-body</span> &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.HolyGrail-nav</span>,</span><br><span class="line">  <span class="selector-class">.HolyGrail-ads</span>,</span><br><span class="line">  <span class="selector-class">.HolyGrail-content</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="参考《阮一峰的网络日志》"><a href="#参考《阮一峰的网络日志》" class="headerlink" title="参考《阮一峰的网络日志》"></a>参考《阮一峰的网络日志》</h3>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令清单</title>
    <url>/2020/03/23/Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<h2 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h2><p>首先，让我们创建一个项目目录，并进入该目录。</p>
<a id="more"></a>

<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir git-demo-project</span><br><span class="line">$ <span class="built_in">cd</span> git-demo-project</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们打算对该项目进行版本管理，第一件事就是使用<code>git init</code>命令，进行初始化。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>git init</code>命令只做一件事，就是在项目根目录下创建一个<code>.git</code>子目录，用来保存版本信息。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls .git</span><br><span class="line"></span><br><span class="line">branches/</span><br><span class="line">config</span><br><span class="line">description</span><br><span class="line">HEAD</span><br><span class="line">hooks/</span><br><span class="line">info/</span><br><span class="line">objects/</span><br><span class="line">refs/</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令显示，<code>.git</code>内部还有一些子目录，这里先不解释它们的含义。</p>
<p><code>git status</code>命令会产生更可读的结果。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">要提交的变更：</span><br><span class="line">    新文件：   test.txt</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码表示，暂存区里面只有一个新文件<code>test.txt</code>，等待写入历史。</p>
<h2 id="git-add-命令"><a href="#git-add-命令" class="headerlink" title="git add 命令"></a>git add 命令</h2><p>上面两步（保存对象和更新暂存区），如果每个文件都做一遍，那是很麻烦的。Git 提供了<code>git add</code>命令简化操作。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add --all</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令相当于，对当前项目所有变动的文件，执行前面的两步操作。</p>
<h2 id="git-commit-命令"><a href="#git-commit-命令" class="headerlink" title="git commit 命令"></a>git commit 命令</h2><p>Git 提供了<code>git commit</code>命令，简化提交操作。保存进暂存区以后，只要<code>git commit</code>一个命令，就同时提交目录结构和说明，生成快照。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"first commit"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>此外，还有两个命令也很有用。</p>
<p><code>git checkout</code>命令用于切换到某个快照。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Router-keep-alive</title>
    <url>/2020/03/14/Router-keep-alive/</url>
    <content><![CDATA[<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p> keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素</p>
<a id="more"></a> 

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//在 home.vue 页面添加两个生命函数</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 声生命函数</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">        name:<span class="string">'home'</span>,</span></span><br><span class="line">        created()&#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">// document.title="首页"</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"home 被创建啦 ^_^"</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"home 被销毁了 o(╥﹏╥)o"</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>其实 keep-alive 的使用很简单。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- index.js 页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"HomeClick"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"AboutClick"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"UserClick"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"ProfileClick"</span>&gt;</span>档案<span class="tag">&lt;/<span class="name">button</span>&gt;</span>       </span><br><span class="line">        <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h3 id="activated-deactivated-生命函数"><a href="#activated-deactivated-生命函数" class="headerlink" title="activated / deactivated 生命函数"></a>activated / deactivated 生命函数</h3><h5 id="①-定义"><a href="#①-定义" class="headerlink" title="① 定义"></a>① 定义</h5><p>  activated，译为“活跃”的，也就是当组件处于活跃状态时将会回调的生命函数。相反，deactivated就是组件处于不活跃的状态。</p>
<h5 id="②-使用场景"><a href="#②-使用场景" class="headerlink" title="② 使用场景"></a>② 使用场景</h5><p>  但是这两个生命函数并不是所有的场景都使用的。只有<strong>使用了 keep-alive 时才可以使用。</strong></p>
<h5 id="③-应用场景"><a href="#③-应用场景" class="headerlink" title="③ 应用场景"></a>③ 应用场景</h5><p>  这里主要用 activated 函数解决上面的bug，此外我们还需要另外一个工具：beforeRouteLeave。beforeRouteLeave 是导航守卫之一，意思就是在监听离开路由时的事情。<br> <strong>第一：删除嵌套路由</strong><br>  bug 的产生是因为一开始在 home 的地址中就有嵌套的路由，即 URL 的地址不仅仅是 /home 而是/home/news 或者 /home/message 。所以我们要先对嵌套的路由进行处理。打开 index.js 在路由映射关系中有关嵌套路由的代码 children 内部删除注释掉的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:<span class="string">'/h ome'</span>,</span><br><span class="line">    component:Home,</span><br><span class="line">    meta:&#123;</span><br><span class="line">            title:<span class="string">'首页'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children:[</span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//  path:"",</span></span><br><span class="line">        <span class="comment">//  redirect:"new"</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">"new"</span>,</span><br><span class="line">            component:HomeNews,</span><br><span class="line">    &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">            path:<span class="string">"message"</span>,</span><br><span class="line">            component:HomeMessage,</span><br><span class="line">    &#125;   </span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong>第二：获取相关路径</strong><br>  既然我们不能在嵌套路由中使用类似“/home/new” 的路径，我们就先<strong>定义一个变量path 来存放在嵌套路由中的路径“/home/new”；</strong><br>  然后使用 <strong>activated</strong> 生命函数，当 home 页面被激活的时候获取当前激活状态下的路径；<br>  最后使用 <strong>beforeRouteLeave</strong> 导航守卫，记录用户离开页面时的路径，并将该路径赋值给变量path，这样当用户再次进入到该页面时，就会使用离开后的路径。具体代码如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// home.vue 文件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">        name:<span class="string">'home'</span>,</span></span><br><span class="line">        data ()&#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">                    path:<span class="string">'/home/new'</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        created()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.title=<span class="string">"首页"</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"home 被创建啦 ^_^"</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line">        destroyed()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"home 被销毁了 o(╥﹏╥)o"</span>)</span></span><br><span class="line">        &#125;,</span><br><span class="line">        activated() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.$router.push(<span class="keyword">this</span>.path)</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        beforeRouteLeave(to,<span class="keyword">from</span>,next)&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.path = <span class="keyword">this</span>.$route.path;</span></span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="1-keepl-alive"><a href="#1-keepl-alive" class="headerlink" title="1.keepl-alive"></a>1.keepl-alive</h4><p>  当用户离开某个组件的时候，不要让该组件频繁的被创建和频繁的被销毁</p>
<h4 id="2-activeted-和-dectivated"><a href="#2-activeted-和-dectivated" class="headerlink" title="2.activeted 和 dectivated"></a>2.activeted 和 dectivated</h4><p>  译为“活跃的/不活跃的”这两个生命函数只有在使用了keep-alive 才可以使用</p>
<p>利用include、exclude属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"bookLists,bookLists"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">exclude</span>=<span class="string">"indexLists"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>include属性表示只有name属性为bookLists，bookLists的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存exclude属性表示除了name属性为indexLists的组件不会被缓存，其它组件都会被缓存</p>
<p>利用meta属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>[</span><br><span class="line"> &#123;</span><br><span class="line">  path:<span class="string">'/'</span>,</span><br><span class="line">  name:<span class="string">'home'</span>,</span><br><span class="line">  components:Home,</span><br><span class="line">  meta:&#123;</span><br><span class="line">    keepAlive:<span class="literal">true</span> <span class="comment">//需要被缓存的组件</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  path:<span class="string">'/book'</span>,</span><br><span class="line">  name:<span class="string">'book'</span>,</span><br><span class="line">  components:Book,</span><br><span class="line">  meta:&#123;</span><br><span class="line">     keepAlive:<span class="literal">false</span> <span class="comment">//不需要被缓存的组件</span></span><br><span class="line"> &#125; </span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"this.$route.meat.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--这里是会被缓存的组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">v-if</span>=<span class="string">"!this.$router.meta.keepAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里是不会被缓存的组件--&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title>Router导航守卫</title>
    <url>/2020/03/13/Router%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/</url>
    <content><![CDATA[<h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p> 导航守卫主要是<strong>监听路由跳转的过程</strong>。比如：<br>  我们都知道HTML中有上图这么一个标题。需求是当用户点击“首页”，标题就变成“首页”；当用户点击“关于”，标题就变成“关于”。目前有两种实现的办法，下面我们分别来看看这两种办法是如何实现的。</p>
<a id="more"></a>

<h4 id="①-生命函数"><a href="#①-生命函数" class="headerlink" title="① 生命函数"></a>① 生命函数</h4><p>  目前我们常用的生命函数主要有三大类，分别是：<strong>created、mounted、updated</strong>。<br> <strong>created</strong>：是在<strong>组件被创建</strong>的时候会回调的函数，然后执行该函数内的内容；<br> <strong>mounted</strong>：当<strong>组件的模板被挂载到DOM</strong>上时就会回调该函数，执行函数内相关的操作；<br> <strong>updated</strong>：只要<strong>页面发生刷新</strong>的时候就会回调该函数从而执行函数内的代码块。<br> 对于上面的需求，可以使用 created 函数来实现。具体代码见下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">        name:<span class="string">'home'</span>,</span></span><br><span class="line">        created()&#123;</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.title=<span class="string">"首页"</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  在 home.vue 页面中添加 created 函数，当组件 home 创建的时候就将标题修改成 “首页”。其余的 “用户” 页面、“关于”页面、“档案”页面也是以此类推，</p>
<p>  但是该方法不足的地方就是：太繁琐啦！我只是想根据导航栏然后修改标题，你就在四个页面都添加了 created 函数</p>
<h3 id="导航守卫使用"><a href="#导航守卫使用" class="headerlink" title="导航守卫使用"></a>导航守卫使用</h3><p>导航守卫就是监听路由的跳转。所以使用的使用分成以下两步：<br> 第一：<strong>使用 beforeEach 确定跳转变化</strong><br> 第二：<strong>使用 meta 确定路由跳转变化时要修改的内容</strong></p>
<h5 id="①-使用-beforeEach-确定跳转变化"><a href="#①-使用-beforeEach-确定跳转变化" class="headerlink" title="①  使用 beforeEach 确定跳转变化"></a>①  使用 beforeEach 确定跳转变化</h5><p>  首先在 router 中有个叫 <strong>beforeEach</strong>  的函数，当我们查看源码时会发现它需要传入一个叫 guard 的 <strong>NavigationGuard 参数</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>这里，将 beforeEach 的参数写成箭头函数的形式，接下来就是添加函数内部的代码。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title=to.title</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> </p>
<h5 id="②-使用-meta-确定跳转变化的内容"><a href="#②-使用-meta-确定跳转变化的内容" class="headerlink" title="② 使用 meta 确定跳转变化的内容"></a>② 使用 meta 确定跳转变化的内容</h5><p>其实meta 很简单，就在路由的配置中添加上下面的代码就可以了，你看：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="attribute">path</span>:<span class="string">'/profile'</span>,</span><br><span class="line">            component:Profile,</span><br><span class="line">            meta:&#123;</span><br><span class="line">                title:<span class="string">'档案'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


<p>发现获取不到mete,是因为路由地址有嵌套路由发生了错误，所以我们可以打印一下该路由</p>
<p> <img src="https://img-blog.csdnimg.cn/20200515181728269.png" alt="img"> </p>
<p>  发现 meta 并没有任何东西，但是在，说明我们获取title的时候不应该用 to.title 而应该用 to.matched[0].mate.title 。所以结合上面两步给出的完整代码应该是这样子的：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">""</span>,</span><br><span class="line">            redirect:<span class="string">'/home'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/home'</span>,</span><br><span class="line">            component:Home,</span><br><span class="line"><span class="comment">//使用 meta 确定路由跳转时要修改的值</span></span><br><span class="line">            meta:&#123;</span><br><span class="line">                title:<span class="string">'首页'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            children:[</span><br><span class="line">                &#123;</span><br><span class="line">                    path:<span class="string">""</span>,</span><br><span class="line">                    redirect:<span class="string">"new"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path:<span class="string">"new"</span>,</span><br><span class="line">                    component:HomeNews,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path:<span class="string">"message"</span>,</span><br><span class="line">                    component:HomeMessage,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/about'</span>,</span><br><span class="line">            component:About,</span><br><span class="line">            meta:&#123;</span><br><span class="line">                title:<span class="string">'关于'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/user/:userID'</span>,</span><br><span class="line">            component:User,</span><br><span class="line">            meta:&#123;</span><br><span class="line">                title:<span class="string">'用户'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/profile'</span>,</span><br><span class="line">            component:Profile,</span><br><span class="line">            meta:&#123;</span><br><span class="line">                title:<span class="string">'档案'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//使用 beforeEach 函数确定转换</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title=to.matched[<span class="number">0</span>].meta.title</span><br><span class="line">    <span class="built_in">console</span>.log(to)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="后置钩子"><a href="#后置钩子" class="headerlink" title="后置钩子"></a>后置钩子</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.afterEach(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title>Router懒加载和参数传递</title>
    <url>/2020/03/13/Router%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h1 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h1><h4 id="1-原因回顾"><a href="#1-原因回顾" class="headerlink" title="1.原因回顾"></a>1.原因回顾</h4><p>  上面已经提及到，当我们把所有的文件都打包到 bound.js 文件夹下，该文件夹就会变得很大，加载缓慢。如果我们<strong>把不同路由对应的组件分割成不同的代码块，分别打包，当路由被访问时才加载相应的组件</strong>，就变得高效起来。</p>
<a id="more"></a>


<h4 id="2-路由懒加载做了什么？"><a href="#2-路由懒加载做了什么？" class="headerlink" title="2.路由懒加载做了什么？"></a>2.路由懒加载做了什么？</h4><p>① 将路由对应的组件<strong>打包</strong>成一个个的 <strong>js 代码块</strong><br> ② 只有在这个路由<strong>被访问</strong>的时候<strong>才加载对应的组件</strong>。</p>
<h4 id="3-懒加载的方式"><a href="#3-懒加载的方式" class="headerlink" title="3.懒加载的方式"></a>3.懒加载的方式</h4><p><strong>① 结合 vue 的异步组件和Webpack 的代码分析</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home  = resolve =&gt; &#123; <span class="keyword">require</span>.ensure([ <span class="string">'../components/Home.vue'</span>],() =&gt; &#123; resolve(<span class="keyword">require</span>(<span class="string">'../components/Home.vue'</span><span class="string">'))&#125;)&#125;;</span></span><br></pre></td></tr></table></figure>


<p> <strong>② AMD写法</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'../components/About.vue'</span>],resolve);</span><br></pre></td></tr></table></figure>

<p>啊？还不会 (⊙_⊙)?？没关系~小编还会最后的杀手锏<br> <strong>③ 箭头函数</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span> (<span class="string">'../components/Home.vue'</span>)</span><br></pre></td></tr></table></figure>

<p>下面小编用方法③结合我们的程序跑一下呗</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在index.js 文件修改</span></span><br><span class="line"><span class="comment">//1.导入</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span> (<span class="string">'../components/home.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span> (<span class="string">'../components/about.vue'</span>)</span><br><span class="line"><span class="keyword">const</span> User = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span> (<span class="string">'../components/user.vue'</span>)</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 负责URL和页面的映射关系</span></span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">""</span>,</span><br><span class="line">            redirect:<span class="string">'/home'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/home'</span>,</span><br><span class="line">            component:Home</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/about'</span>,</span><br><span class="line">            component:About</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/user/:userID'</span>,</span><br><span class="line">            component:User</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    ],</span><br><span class="line">    mode:<span class="string">'history'</span>,</span><br><span class="line">    linkActiveClass:<span class="string">"warp"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.导出路由</span></span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p>  传递参数主要有两种类型： params 和 query 。其中 params 就是动态路由。</p>
<h4 id="1-params"><a href="#1-params" class="headerlink" title="1.params"></a>1.params</h4><p>主要分成下面三个步骤：<br> <strong>① 配置路由格式</strong><br>  说白了就是在 routes 映射关系中的 path 后面添加多一个变量，该变量就是要传递的参数。<br> 比如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 负责URL和页面的映射关系</span></span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">""</span>,</span><br><span class="line">            redirect:<span class="string">'/home'</span></span><br><span class="line">        &#125;,      </span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/user/:userID'</span>,</span><br><span class="line">            component:User</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  我们希望在“user” 页面的URL中添加上用户的ID。所以在 routes 的 path 中添加了userID 变量，该变量就是想要传递的参数</p>
<p><strong>② 给参数赋值</strong><br>  上面一步我们已经为路由的路径后面添加多了userID 参数，接下来我们就要为这个参数赋值。<br> 在路由对象的 data 中声明该变量并且为变量赋值。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  data ()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">          userID:<span class="string">"李四"</span></span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  我们希望用户“李四” 登陆系统后能将他的ID传递到用户页面的URL中。所以为 userID 赋值为 “lisi”。</p>
<p><strong>③ 显示变量</strong><br> 上面一步我们已经有了数据，接下来就是将该数据显示在用户页面的URL中。<br>  使用<strong>计算属性</strong>重新定义一个变量，然后通过<strong>$route 获取原来变量的值并返回给新的变量</strong>。最后一定要记得，在 <strong>route-link 标签的 to 属性也要添加上该变量</strong>，否则不能成功跳转页面。比如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示数据的模板</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;router-link to=<span class="string">"/home"</span> tag=<span class="string">"button"</span> replace&gt;首页&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">        &lt;router-link to="/</span>about<span class="string">" tag="</span>button<span class="string">" replace&gt;关于&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;router-link :to="</span><span class="string">'/user/'</span>+userID<span class="string">"tag="</span>button<span class="string">" &gt;用户&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">        &lt;h3&gt;&#123;&#123;userid&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">        &lt;h2&gt;&#123;&#123;$route.params.userID&#125;&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;  </span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//路由配置</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  name: 'App',</span></span><br><span class="line"><span class="string">  data ()&#123;</span></span><br><span class="line"><span class="string">      return &#123;</span></span><br><span class="line"><span class="string">          userID:"</span>李四<span class="string">"</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string"> computed:&#123;</span></span><br><span class="line"><span class="string">      userid()&#123;</span></span><br><span class="line"><span class="string">          return this.$route.params.userID</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>  在该例子中，定义了新的变量 userid，然后通过 route.params.userID获取了userID的值，最后在模板中显示如下：</p>
<h4 id="2-query-类型"><a href="#2-query-类型" class="headerlink" title="2.query 类型"></a>2.query 类型</h4><p>  在进行正式配置之前，我们要准备前期的工作，重新创建一个 profile.vue 组件。<br> 我们通过 query 传递参数的时候，也可以大概分成下面三步：<br> <strong>① 配置路由</strong><br> 这个配置路由的方式就是跟往常配置路由的方式是一样的。比如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 负责URL和页面的映射关系</span></span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">""</span>,</span><br><span class="line">            redirect:<span class="string">'/home'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/about'</span>,</span><br><span class="line">            component:About</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/user/:userID'</span>,</span><br><span class="line">            component:User</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/profile'</span>,</span><br><span class="line">            component:Profile</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在这里，当路径出现 “/profile” 时就跳转到 profile.vue 组件的页面。</p>
<p><strong>② 通过router-link 实现跳转</strong><br> 在模板中通过 router-link 实现路径和页面的跳转。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span> <span class="attr">tag</span>=<span class="string">"button"</span> <span class="attr">replace</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span> <span class="attr">tag</span>=<span class="string">"button"</span> <span class="attr">replace</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'/user/'+userID"</span><span class="attr">tag</span>=<span class="string">"button"</span> <span class="attr">replace</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">'/profile'</span>&gt;</span>档案<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;userid&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$route.params.userID&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当用户点击了 “档案” ，就会跳转到 “/profile”路径下的 profile.vue组件。<br> <strong>③ 传递参数</strong><br>  query 和params不同的是，query传递的是一个对象，所以在 router-link 标签的 to 属性不是单单的传递一个变量，而是一个对象。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"&#123;path:'/profile' , query:&#123;name:'zhangsan',age:18&#125;&#125;"</span>&gt;</span>档案<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用query传递参数是需要注意两点：<br>  第一：<strong>传递的是对象</strong>。因为传递的是对象，所以在 to 前面要使用 v-bind（简写是 ：）来获取，否则如果是 to=“{…}” 传递的是一个{}字符串儿不是一个对象。<br>  第二：<strong>query 也是对象</strong>，所以在query的内部可以传递很多的属性。<br> 上面的例子中，当用户点击的“档案” ，跳转到“档案”页面时，该页面的URL就会显示 query 对象传递过去的参数。比如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 profile.vue 添加</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;我是profile&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;&#123;&#123;$route.query&#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure>



<h4 id="通过代码来传递参数"><a href="#通过代码来传递参数" class="headerlink" title="通过代码来传递参数"></a>通过代码来传递参数</h4><h4 id="1-params-的代码书写方式"><a href="#1-params-的代码书写方式" class="headerlink" title="1.params 的代码书写方式"></a>1.params 的代码书写方式</h4><p>  首先就是把 router-link 变成 <strong>button 标签</strong>，紧接着为 button <strong>添加点击事件</strong>，最后再绑定的事件通过 <strong>$route.push 获取path</strong>。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1.将router-link 转换成button 标签并添加点击事件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"HomeClick"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"AboutClick"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"UserClick"</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"ProfileClick"</span>&gt;</span>档案<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123;userid&#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$route.params.userID&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  data ()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">          userID:<span class="string">"李四"</span></span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">      userid()&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> <span class="keyword">this</span>.$route.params.userID</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript"><span class="comment">//绑定点击事件</span></span></span><br><span class="line">  methods:&#123;</span><br><span class="line">      HomeClick()&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$router.push(<span class="string">'/home'</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      AboutClick()&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$router.push(<span class="string">'/about'</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      UserClick()&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$router.push(<span class="string">'/user/'</span> + <span class="keyword">this</span>.userID);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      ProfileClick()&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$router.push(&#123;</span></span><br><span class="line"><span class="actionscript">              path:<span class="string">'/profile'</span>,</span></span><br><span class="line">              query:&#123;</span><br><span class="line"><span class="actionscript">                  name:<span class="string">'zhangsan'</span>,</span></span><br><span class="line">                  age:18</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里要主要的是两点：<br>  <strong>① 地址拼接：</strong> 常量需要用引号包括，变量不需要引号包裹，常量和变浪之间通过 + 进行拼接。比如： this.$router.push(‘/user/‘ + this.userID); /user 代表路径，是一个常量，需要用引号包裹，而 userID 是变量，通过this来获取当前的变量；<br>  <strong>② 参数传递</strong>：如果连接中涉及到参数传递的，路径后面要加“/”。比如(‘/user/‘ + this.userID);  我们需要将userID传递到URL中，所以路径 /user 后面要加 /</p>
<h4 id="2-query-代码的书写方式"><a href="#2-query-代码的书写方式" class="headerlink" title="2.query 代码的书写方式"></a>2.query 代码的书写方式</h4><p>  依旧是通过 <strong>$router.push</strong> 来获取，只是 push 内部不再是简简单单的变量，而是一个<strong>对象</strong>。对象内部有 path 和 query，而query又是一个对象，里面包含了 name 和age 两个属性。如下图所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ProfileClick()&#123;</span><br><span class="line">         <span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">             path:<span class="string">'/profile'</span>,</span><br><span class="line">             query:&#123;</span><br><span class="line">                 name:<span class="string">'zhangsan'</span>,</span><br><span class="line">                 age:<span class="number">18</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title>Router的基本使用</title>
    <url>/2020/03/12/Router%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="路由安装和配置"><a href="#路由安装和配置" class="headerlink" title="路由安装和配置"></a>路由安装和配置</h1><h4 id="1-安装路由"><a href="#1-安装路由" class="headerlink" title="1.安装路由"></a>1.安装路由</h4><p>  有两种方式，一是通过<strong>命令 npm install vue-router –save</strong>安装，二是在<strong>创建项目</strong>的时候就选择安装路由</p>
<p>  当安装完成后，会在src文件夹下默认创建 router 文件夹，router文件夹下又会自动创建 index.js文件。</p>
<a id="more"></a>

<p> <img src="https://img-blog.csdnimg.cn/20200515162309660.png" alt="在这里插入图片描述"> </p>
<h4 id="2-使用路由的步骤"><a href="#2-使用路由的步骤" class="headerlink" title="2.使用路由的步骤"></a>2.使用路由的步骤</h4><p>  这里主要分成四步：① 导入路由插件  ② 使用路由插件  ③创建路由对象  ④使用路由对象<br> <strong>① 导入路由插件</strong><br> 在通过npm安装好路由之后，如果想真正的使用，首先肯定是导入路由啦。在router文件夹下的index.js文件写入下面的代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br></pre></td></tr></table></figure>

<p><strong>② 使用路由插件</strong><br>  导入好的路由并不能直接使用，必须通过<strong>Vue.use()</strong>才可以使用。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Vue</span><span class="selector-class">.use</span>(<span class="selector-tag">VueRouter</span>)</span><br></pre></td></tr></table></figure>

<p><strong>③ 创建路由对象</strong><br>  和创建Vue实例一样的创建方法，值得注意的是这里的<strong>routes</strong>属性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 负责URL和页面的映射关系</span></span><br><span class="line">    routes:[</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>④ 使用路由对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先得在index.js文件导出路由</span></span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>



<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//然后在main.js文件使用路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>为什么导入路由的路径是 ./router 而不是 ./router/index.js 。因为在执行的时候，会<strong>默认先执行index的文件</strong>，所以写不写index的效果是一样的。</p>
<h4 id="编写路由映射关系"><a href="#编写路由映射关系" class="headerlink" title="编写路由映射关系"></a>编写路由映射关系</h4><h5 id="1-创建路由组件"><a href="#1-创建路由组件" class="headerlink" title="1.创建路由组件"></a>1.创建路由组件</h5><p>因为映射关系是映射页面和URL的关系，所以我们得先准备好页面。<br> 创建 home.vue 和 about.vue文件，然后在该文件中书写相关的内容</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//about.vue文件内容</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;关于&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;在这里你可以问到任何你想问的问题&lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">    h1&#123;</span></span><br><span class="line"><span class="regexp">        color: aquamarine;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//home.vue文件内容</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;首页&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;span&gt;我是首页&lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">    h1&#123;</span></span><br><span class="line"><span class="regexp">        color: red;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-配置路由映射关系"><a href="#2-配置路由映射关系" class="headerlink" title="2.配置路由映射关系"></a>2.配置路由映射关系</h5><p>  routes主要放两个东西：<strong>路径 path + 组件 component</strong>。每一个映射关系就是一个对象，所以我们可以这样写：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.导入</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../components/home.vue'</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'../components/about.vue'</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 负责URL和页面的映射关系</span></span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/home'</span>,</span><br><span class="line">            component:Home</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/about'</span>,</span><br><span class="line">            component:About</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.导出路由</span></span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>  当页面的地址中有 “/home ”就显示home相关的页面；当页面的地址中有 “/about ”就显示about相关的页面.</p>
<h5 id="3-使用路由"><a href="#3-使用路由" class="headerlink" title="3.使用路由"></a>3.使用路由</h5><p>  页面和URL的映射关系已经建立好了，但是得要有东西来触发它们真正起作用，所以就涉及到另外两个重要的标签： router-link 和router-view<br> <strong>① router-link：</strong>是vue-router 中已经注册过多的组件，其功能类似于a标签，<strong>点击到文字就跳转到相应的页面</strong>。<br> <strong>② router-view：</strong>它的作用就是决定<strong>页面的显示</strong>。<br> 比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在App.vue文件中写入上面的代码，结果如下图所示：</p>
<p> <img src="https://img-blog.csdnimg.cn/2020051516255867.png" alt="img"> </p>
<h4 id="路由的默认路径"><a href="#路由的默认路径" class="headerlink" title="路由的默认路径"></a>路由的默认路径</h4><p>redirect又叫重定向，意思是当path为空的时候，就跳转到redirect指定的路径。<br> 比如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 负责URL和页面的映射关系</span></span><br><span class="line">    routes:[</span><br><span class="line">    <span class="comment">//路由的默认路径</span></span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">""</span>,</span><br><span class="line">            redirect:<span class="string">'/home'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/home'</span>,</span><br><span class="line">            component:Home</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/about'</span>,</span><br><span class="line">            component:About</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 当路径为空的时候，我们就跳转到‘/home’路径下，然后根据映射关系，跳转到/home路径下就显示首页的内容。 </p>
<p>在创建router对象的时候添加多一个属性： mode：history</p>
<p>将hash模式变成history模式</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">    <span class="comment">// 负责URL和页面的映射关系</span></span><br><span class="line">    routes:[</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">""</span>,</span><br><span class="line">            redirect:<span class="string">'/home'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/home'</span>,</span><br><span class="line">            component:Home</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path:<span class="string">'/about'</span>,</span><br><span class="line">            component:About</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    ],</span><br><span class="line">    mode:<span class="string">'history'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="router-link补充"><a href="#router-link补充" class="headerlink" title="router-link补充"></a>router-link补充</h4><p><strong>① tag：指定 router-link 被渲染成什么组件。</strong><br>  router-link 默认被渲染成 a标签，如果你想要渲染成别的标签，添加 tag 属性即可，具体用法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span> <span class="attr">tag</span>=<span class="string">"button"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span> <span class="attr">tag</span>=<span class="string">"button"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <strong>② to ：指定跳转的路径。</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  </p>
<p><strong>③ replace：不会留下历史记录，即点击后退键不会返回到上一个页面中。</strong><br>  router-link 默认是采用 pushState 的方式保留历史记录，如果在某些特殊的情况下不允许用户点来点去就乐意添加该属性。用法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home"</span> <span class="attr">replace</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/about"</span> <span class="attr">replace</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <strong>④ activeClass：激活状态。</strong>  意思是当 router-link 对应的路由匹配成功时，会自动给当前元素设置一个叫router-link-actice的class，设置active-class 可以修改默认的名称。用法如下：</p>
<p><strong>4.1 单一书写</strong> 这种写法是直接嵌套在标签内部，比如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=<span class="string">"/home"</span> tag=<span class="string">"button"</span> replace active-<span class="keyword">class</span>=<span class="string">"warp"</span>&gt;首页&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=<span class="string">"/about"</span> tag=<span class="string">"button"</span> replace active-<span class="keyword">class</span>=<span class="string">"warp"</span>&gt;关于&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 批量书写</strong> 通过在router 对象添加属性 linkActiveClass 。比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line"><span class="comment">// 负责URL和页面的映射关系</span></span><br><span class="line">    routes:[</span><br><span class="line">    linkActiveClass:<span class="string">"warp"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="编程式导航跳转路由"><a href="#编程式导航跳转路由" class="headerlink" title="编程式导航跳转路由"></a>编程式导航跳转路由</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>① 绑定事件</strong><br>  绑定事件的对象是需要路由跳转的地方，比如点击 “首页” 就跳转到 “/home”页面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"homeClick"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"aboutClick"</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>② 添加  this.$router属性</strong><br> 在导出路由对象的地方添加属性如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  methods:&#123;</span><br><span class="line">      homeClick()&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$router.push(<span class="string">'./home'</span>);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      aboutClick()&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.$router.push(<span class="string">'./about'</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex的action和module</title>
    <url>/2020/03/18/Vuex%E7%9A%84action%E5%92%8Cmodule/</url>
    <content><![CDATA[<h1 id="action"><a href="#action" class="headerlink" title="action"></a>action</h1><h5 id="1-产生原因"><a href="#1-产生原因" class="headerlink" title="1.产生原因"></a>1.产生原因</h5><p>  当<strong>在mutations中进行异步操作时，Devtool不能够实时跟踪，导致最终在Devtool中记录的是错误的信息</strong>。比如：</p>
<a id="more"></a>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; </span><br><span class="line">    state:&#123;</span><br><span class="line">      info:&#123;</span><br><span class="line">        name:<span class="string">'haha'</span>,</span><br><span class="line">        age:<span class="number">13</span>,</span><br><span class="line">        height:<span class="number">1.45</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">   mutations:&#123;</span><br><span class="line">      changeInfo(state)&#123;</span><br><span class="line">        <span class="comment">// 异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          state.info.name=<span class="string">'哈哈'</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码主要是同异步操作来将“haha”修改成“哈哈”。结果如图所示：</p>
<p> <img src="https://img-blog.csdnimg.cn/20200516162350241.png" alt="img"> </p>
<p> <img src="https://img-blog.csdnimg.cn/2020051616242921.png" alt="img"> </p>
<p>  当在mutations使用异步操作时，虽然页面中的数据修改了，但是在Vuex总state记录的仍旧是以前的数据。<br>  其实数据是修改成功了，但是mutations中的Devtool在跟踪时没有记录，就导致记录的的错误的信息。<br>  所以不能再mutations中进行一步操作，这时我们就需要action帮我们进行一步操作。</p>
<h5 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h5><p>Action类似于Mutation, 但是是<strong>用来代替Mutation进行异步操作的</strong>。</p>
<h5 id="3-使用方式"><a href="#3-使用方式" class="headerlink" title="3.使用方式"></a>3.使用方式</h5><p>使用方式和mutations类似，但是有两点不同:<br> <strong>① 参数</strong>：传入的参数是<strong>context</strong>。该参数相当于store对象<br> <strong>② 调用方式</strong>：使用<strong>dispatch</strong>调用，而不是使用commit<br> 具体见下面的代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; </span><br><span class="line">   mutations:&#123;</span><br><span class="line">      state.info.name=<span class="string">'哈哈'</span></span><br><span class="line">      &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">      achangeInfo(context)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          context.commit(<span class="string">'changeInfo'</span>)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store/index.js'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeInfo()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.dispatch(<span class="string">'achangeInfo'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200516162350241.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/20200516162507984.png" alt="img"> </p>
<p>可以发现mutations中的Devtool记录的数据也跟着发生了改变。</p>
<h5 id="4-传递参数"><a href="#4-传递参数" class="headerlink" title="4.传递参数"></a>4.传递参数</h5><p>传递参数的方式和mutations类似，下面进行简单的传递字符串参数，具体代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123; </span><br><span class="line">   mutations:&#123;</span><br><span class="line">      state.info.name=<span class="string">'哈哈'</span></span><br><span class="line">      &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">      achangeInfo(context,payload)&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          context.commit(<span class="string">'changeInfo'</span>)</span><br><span class="line">          <span class="built_in">console</span>.log(payload)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'../store/index.js'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeInfo()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.dispatch(<span class="string">'achangeInfo'</span>,<span class="string">'我是payload'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>发现传递参数也是可以的，并且成功在控制台中显示了。</p>
<h5 id="5-action内部使用Promise"><a href="#5-action内部使用Promise" class="headerlink" title="5.action内部使用Promise"></a>5.action内部使用Promise</h5><p>  当数据commit之后就意味着修改成功了，此时<strong>想要告诉外界，数据已经修改成功了并且除了修改数据之外我们还可以做别的操作</strong>。该需求可以用Promise实现，具体先看下面代码：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">actions:&#123;</span><br><span class="line">   achangeInfo(context,payload)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">       setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">         context.commit(<span class="string">'changeInfo'</span>)</span><br><span class="line">         <span class="built_in">console</span>.log(payload)</span><br><span class="line">         resolve(<span class="string">'1111'</span>)</span><br><span class="line">       &#125;,<span class="number">1000</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    changeInfo()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store</span></span><br><span class="line"><span class="actionscript">      .dispatch(<span class="string">'achangeInfo'</span>,<span class="string">'我是payload'</span>)</span></span><br><span class="line"><span class="javascript">      .then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(res)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  上述代码的主要作用是当数据修改成功之后，就在控制台上打印“1111”。具体思路是当action运行到commit方法时，就会执行changeInfo函数，然后在回调changeInfo函数。<br>  本案例中，当执行achangeInfo函数时，就返回 Promise，而achangeInfo是通过dispatch调用的，其上述的代码可以等价为下面的代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    changeInfo()&#123;</span><br><span class="line"><span class="actionscript">      <span class="comment">//this.$store</span></span></span><br><span class="line"><span class="actionscript">     <span class="comment">//.dispatch('achangeInfo','我是payload')</span></span></span><br><span class="line"><span class="javascript">     <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">            context.commit(<span class="string">'changeInfo'</span>)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(payload)</span></span><br><span class="line"><span class="actionscript">            resolve(<span class="string">'1111'</span>)</span></span><br><span class="line">          &#125;,1000)</span><br><span class="line"><span class="javascript">      .then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(res)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  以上就是action相关的知识，总结起来就是两点：<strong>处理异步操作和在内部使用Promise。</strong></p>
<h1 id="module"><a href="#module" class="headerlink" title="module"></a>module</h1><h5 id="1-产生原因-1"><a href="#1-产生原因-1" class="headerlink" title="1.产生原因"></a>1.产生原因</h5><p>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?<br>  Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理，当应用变得非常复杂时,store对象就有可能变得相当臃肿.<br>  为了解决这个问题, <strong>Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutation、action、getters等。</strong></p>
<h5 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2.使用方式"></a>2.使用方式</h5><p>  正如上面所提到的，我们可以在module中声明多个模块，然后在每个模块中书写自己模块的state、mutation、action、getters。下面进行逐步的展示。</p>
<h6 id="①-module中的state"><a href="#①-module中的state" class="headerlink" title="① module中的state"></a>① module中的state</h6><p><strong>1-1 module中state的定义</strong><br> 定义的方式和store中定义state的方式一样，具体见下面的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单独模块的书写</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    name:<span class="string">'我是moduleA的name'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在store对象声明模块A</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        a:moduleA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> 在store对象的module中声明了moduleA，并且moduleA自己的state中有一个name变量。<br> <strong>1-2 module中state的使用</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>-----Vuex中module的测试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.a.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="②-模块中的mutations"><a href="#②-模块中的mutations" class="headerlink" title="② 模块中的mutations"></a>② 模块中的mutations</h6><p><strong>2-1 module中mutations的定义</strong><br> 定义的方式和store中的mutations定义的方式一样，具体见下面的代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单独模块的书写</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    name:<span class="string">'我是moduleA的name'</span></span><br><span class="line">  &#125;，</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    updataName(state,payload)&#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在store对象声明模块A</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        a:moduleA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>声明了 根据用户传递的参数修改姓名的updataName方法<br> <strong>2-2 module中mutations的使用</strong><br> 使用方式和store对象中的mutations一样，<strong>通过commit方法提交</strong>，具体代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>-----Vuex中module的测试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.a.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"updateName"</span>&gt;</span>修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateName()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.commit(<span class="string">'updataName'</span>,<span class="string">'李四'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p>这里要注意两点：<br>  第一，<strong>命名不重复</strong>。模块内的mutations和store对象的mutations命名不要重复，否则浏览器不知道提交谁的mutations<br>  第二，<strong>查找顺序</strong>。使用commit方法提交时，首先会查找store对象的mutations，看看是否有该方法，如果没有就是去模块内的mutations查找。</p>
<h6 id="③-模块中的getters"><a href="#③-模块中的getters" class="headerlink" title="③ 模块中的getters"></a>③ 模块中的getters</h6><p><strong>3-1 模块中getters的定义</strong><br>  定义的方式和在store中定义的方式类似。不同的是，如果在模块中想要<strong>使用store中state内的变量，需要通过rootState参数进行获取</strong>，具体代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单独模块的书写</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    name:<span class="string">'我是moduleA的name'</span></span><br><span class="line">  &#125;，</span><br><span class="line">  getters:&#123;</span><br><span class="line">    <span class="comment">//1.普通应用</span></span><br><span class="line">    fullname(state)&#123;</span><br><span class="line">      <span class="keyword">return</span> state.name +<span class="string">'1111'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//2.应用本模块的getters</span></span><br><span class="line">    fullname2(state,getters)&#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname +<span class="string">'2222'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    fullname3(state,getters,rootState)&#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname2 + rootState.counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在store对象声明模块A</span></span><br><span class="line"><span class="keyword">const</span> store = new Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        a:moduleA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>用法1是<strong>简单的getters应用</strong>，将name的值后面追加上“1111”；<br> 用法2是<strong>获取本模块中的getters</strong>，然后对获取到的结果再追加上“2222”；<br> 用法3是<strong>获取store中的counter</strong>，通过rootState获取，然后再追加到到fullname2的结果中。<br> <strong>3-2 模块中getters的使用</strong><br> 使用方式和store中的类似，具体代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>-----Vuex中module的测试-----<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.fullname&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.fullname2&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.fullname3&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="④-module的action"><a href="#④-module的action" class="headerlink" title="④ module的action"></a>④ module的action</h6><p><strong>4-1 定义的方式</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单独模块的书写</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    name:<span class="string">'我是moduleA的name'</span></span><br><span class="line">  &#125;，</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    updataName(state,payload)&#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">    aupdateName(context)&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        context.commit(<span class="string">'updataName'</span>,<span class="string">'王五'</span>)</span><br><span class="line">      &#125;,<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在store对象声明模块A</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        a:moduleA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过setTimeout来模拟异步操作，修改name的值为“王五”<br> <strong>4-2 使用方式</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>-----Vuex中module的测试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.a.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"asycnUpdateName"</span>&gt;</span>异步修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  methods:&#123;</span><br><span class="line">    asycnUpdateName()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.dispatch(<span class="string">'aupdateName'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="④-module的action-1"><a href="#④-module的action-1" class="headerlink" title="④ module的action"></a>④ module的action</h6><p><strong>4-1 定义的方式</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单独模块的书写</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state:&#123;</span><br><span class="line">    name:<span class="string">'我是moduleA的name'</span></span><br><span class="line">  &#125;，</span><br><span class="line">  mutations:&#123;</span><br><span class="line">    updataName(state,payload)&#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions:&#123;</span><br><span class="line">    aupdateName(context)&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        context.commit(<span class="string">'updataName'</span>,<span class="string">'王五'</span>)</span><br><span class="line">      &#125;,<span class="number">10</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在store对象声明模块A</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    modules:&#123;</span><br><span class="line">        a:moduleA</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过setTimeout来模拟异步操作，修改name的值为“王五”<br> <strong>4-2 使用方式</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>-----Vuex中module的测试<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.a.name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"asycnUpdateName"</span>&gt;</span>异步修改名字<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  methods:&#123;</span><br><span class="line">    asycnUpdateName()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.dispatch(<span class="string">'aupdateName'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p> 这里需要注意的是，在模块中，<strong>context.commit()仅仅提交自己模块的方法而不包括store中的方法。</strong> </p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex基本使用</title>
    <url>/2020/03/16/Vuex%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><p>  <strong>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</strong>它采用 <strong>集中式存储管理</strong> 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<a id="more"></a>

<p>  当组件1、组件2、组件3 三个组件之间<strong>共享某些状态</strong>的时候，我们不能将该状态定义在组件1中，也不能定义在组件2中，也不能定义在组件3中，因为我们没有办法确保三个组件之间是有关联的。<br>  如果我们将该状态定义在组件1中，然后组件3想要用该状态，但是组件1在组件树的顶层，而组件3却在组件数的最底层，这样一层一层调用十分复杂，因此我们需要另外一个东西来存放并且管理组件之间共享的状态，这个东西就是Vuex。<br>  综上所述，<strong>Vuex是一个管理共享状态的管家，并且该状态是响应式的</strong>。</p>
<h5 id="2-管理什么状态？"><a href="#2-管理什么状态？" class="headerlink" title="2.管理什么状态？"></a>2.管理什么状态？</h5><p>  不是所有的状态都可以放到Vuex的，只有<strong>多个组件中可能会共享的状态</strong>才放到Vuex中，比如下面的这些：<br> <strong>① 用户相关</strong>：用户的登录状态、用户名称、头像、地理位置信息等等。<br> <strong>② 商品相关</strong>：商品的收藏、购物车中的物品等等。<br>  这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的</p>
<h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><h5 id="1-单页面状态管理"><a href="#1-单页面状态管理" class="headerlink" title="1.单页面状态管理"></a>1.单页面状态管理</h5><p> <img src="https://img-blog.csdnimg.cn/20200516155101159.png" alt="img"> </p>
<p>  首先，可以简单理解成变量，因为变量也是可以用来保存状态的；，状态的显示是通过视图显示的，所以State指向View；  然后如果视图中有一些，就会传递给，所以View指向Actions； 最后该行为可能会，所以Action指向了State，具体的代码如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"counter++"</span> &gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"counter--"</span> &gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            message:<span class="string">"我是标题"</span>,</span></span><br><span class="line">            counter:0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  在该页面中，message 和 counter 都可以看成是State，然后 template 看作是View，@click点击事件可以看成Action。message的内容在template中显示，也是证实了State指向View；template中的button增加了点击事件，证实了View指向Action；当用户点击了“+ - ”时会就修改counter的数值，证实了Action指向State。<br> <strong>因为State、View、Action都是在同一个页面中的，所以叫做单页面状态管理。</strong></p>
<h5 id="2-多页面管理"><a href="#2-多页面管理" class="headerlink" title="2.多页面管理"></a>2.多页面管理</h5><p>  在上面例子的基础上，我们在创建一个页面，该页面和上个例子中的页面共享counter变量，我们用vuex实现的步骤如下：<br> <strong>① 安装vuex</strong>：通过命令 <strong>npm install vuex –save</strong> 安装<br> <strong>② 引用插件：</strong>因为vuex是一个插件，所以我们要通过 <strong>Vue.use()</strong>来引用插件<br> <strong>③ 创建实例</strong>：通过命令 <strong>const store = new Vuex.store（）</strong>命令来创建，这里要注意的是，我们<strong>创建的是Vuex插件中的store方法</strong><br> <strong>④ 书写共享状态：</strong>在Vuex中一般有固定的内容填写，包括：state、mutations、action、getters、modules<br> <strong>⑤ 使用共享状态</strong>：通过 <strong>$store.state.XXX</strong>来使用，代码具体如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vuex代码</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.引用插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">// 2.创建实例</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      counter:<span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    actions:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    modules:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//3.导出实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一个组件的代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"counter++"</span> &gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"counter--"</span> &gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hellovue</span>&gt;</span><span class="tag">&lt;/<span class="name">hellovue</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> hellovue <span class="keyword">from</span> <span class="string">'./components/HelloWorld.vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  components:&#123;</span><br><span class="line">    hellovue</span><br><span class="line">  &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            message:<span class="string">"我是组件1"</span>,</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第二个组件的代码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hello"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'HelloWorld'</span>,</span></span><br><span class="line">  data()&#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span>&#123;</span></span><br><span class="line"><span class="actionscript">      message:<span class="string">"我是组件2"</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  在上面的代码中，我们将共享的变量 counter 放在了vuex.store 的 state 中，并且通过 <strong>$store.stats.counter</strong> 使用该变量。效果图如下所示：</p>
<p> <img src="https://img-blog.csdnimg.cn/20200516155101160.png" alt="在这里插入图片描述"> </p>
<p>  在此，已经实现了counter的共享，但是我们还没有实现当用户点击“+ - ”时counter的变化状态</p>
<h5 id="3-状态变化的原理"><a href="#3-状态变化的原理" class="headerlink" title="3.状态变化的原理"></a>3.状态变化的原理</h5><p>  基于上面的例子，如果当多个组件都想要修改counter的值时，就会可能遇到这样的情况，就是<strong>不知道到底是谁修改过counter的值</strong>，这样不利于后面代码的追踪，所以我们希望有一个东西来记录谁修改过状态，而下面的这幅图就是状态改变的实质</p>
<p> <img src="https://img-blog.csdnimg.cn/20200516155101127.png" alt="img"> </p>
<p>状态改变可以有两条路径：<br> <strong>①Vue Components –&gt; State</strong><br>  通过这条路径修改状态的话，就会发生刚刚说的事情，<strong>根本不知道谁修改过state</strong>，所以官方是不建议这样直接修改state<br> <strong>② Vue Components –&gt; Action –&gt; Mutations –&gt; State</strong><br>  <strong>Mutations:处理同步操作</strong>，内部有个叫 <strong>Devtools</strong>的插件，该插件的作用就是<strong>记录修改Vuex的状态</strong>；<br> <strong>Action ：处理异步操作</strong>，比如网络请求，所以Action 的另外一头指向了backend（后端）</p>
<h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><p>  通俗的理解就是里面装着一些<strong>改变数据方法的集合</strong>。把处理数据逻辑方法全部放在mutations里面，使得数据和视图分离。</p>
<h4 id="切记：Vuex中store数据改变的唯一方法就是mutation！"><a href="#切记：Vuex中store数据改变的唯一方法就是mutation！" class="headerlink" title="切记：Vuex中store数据改变的唯一方法就是mutation！"></a>切记：Vuex中store数据改变的唯一方法就是mutation！</h4><h5 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h5><p><strong>① 在mutations中书写先关的操作</strong>。其实就是在mutation声明方法，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      counter:<span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">      increase(state)&#123;</span><br><span class="line">        state.counter++</span><br><span class="line">      &#125;,</span><br><span class="line">      decrease(state)&#123;</span><br><span class="line">        state.counter--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  任何修改Vuex状态的数据都在mutations中处理，上述代码中，声明了两个方法 increase 和 decrease，默认的参数传递的都是state，然后主要的操作就是对counter进行加法运算和减法运算。<br> <strong>② 在组件中引用mutations</strong><br>  在写好了相关的处理操作后，我们在需要的页面中引用mutations即可，引入时不是直接引入mutation的方法，而是通过commit提交相应的方法。具体代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addcounter"</span> &gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"deccounter"</span> &gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hellovue</span>&gt;</span><span class="tag">&lt;/<span class="name">hellovue</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> hellovue <span class="keyword">from</span> <span class="string">'./components/HelloWorld.vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  components:&#123;</span><br><span class="line">    hellovue</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    addcounter()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.commit(<span class="string">'increase'</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    deccounter()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.commit(<span class="string">'decrease'</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            message:<span class="string">"我是组件1"</span>,</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  上述代码中，定义了adcounter和deccounter两个方法，在两个方法中分别通过  <strong>this.$store.commit(‘decrease’)</strong> 来获取mutations中的方法。实现后的效果如下所示：</p>
<p> <img src="https://img-blog.csdnimg.cn/20200516155448850.png" alt="img"> </p>
<p>  当点击 “+或者 - ”时，右上方就会跟踪到increate或者decreate方法，当点击其中一个方法时，在右下方会显示该状态下的counter具体数值是多少，从而达到了追踪和记录的目的。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex的getters</title>
    <url>/2020/03/17/Vuex%E7%9A%84getters/</url>
    <content><![CDATA[<h1 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h1><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><p>  getters 相当于我们之前使用过的计算属性。<strong>当数据要经过一系列变化时，我们就可以将这一系列的变化写在getters内部。</strong></p>
<a id="more"></a>

<h5 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h5><p>  getters的使用方法和mutation一样，通过声明<strong>方法</strong>然后在方法中书写相应的代码即可并且<strong>默认的参数是state</strong>。比如当我们计算counter的平方时可以有下面两种做法。<br> <strong>做法一：直接运算</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;&#123;&#123;<span class="variable">$store</span>.state.counter * <span class="variable">$store</span>.state.counter&#125;&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>

<p>  这种做法就是直接将运算也放在了显示内容上，如果别的页面中同样需要用到counter平方时，我们也需要在引入上面的代码，不仅仅利用不方便而且代码量看起来也快很多，所以一般我们都采用第二种做法。<br> <strong>做法二：使用getters</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js文件</span></span><br><span class="line">getters:&#123;</span><br><span class="line">      powerCounter(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> state.counter * state.counter</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--App.vue 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>----做法一------<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.counter * $store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>--------做法二：getters的使用--------<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    &#123;&#123;$store.getters.powerCounter&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span></span></span><br></pre></td></tr></table></figure>

<p>  首先在getters中声明了名字为<strong>powerCounter的方法</strong>，然后在方法中<strong>计算counter的平方</strong>，最后通过<strong>调用 $store.getters.powerCounter</strong> 就可以直接将counter的平方显示在页面上。下面是效果图</p>
<p> <img src="https://img-blog.csdnimg.cn/20200516160103592.png" alt="img"> </p>
<p>  上述的getters只是处理的单一数值运算，下面看看用getters处理别的案例。现在state中有多个学生，但只显示年龄大于20岁的学生，具体代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js 文件</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      student:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">100</span>,<span class="attr">name</span>:<span class="string">'zhangsan'</span>,<span class="attr">age</span>:<span class="number">21</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">200</span>,<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">300</span>,<span class="attr">name</span>:<span class="string">'wangwu'</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">400</span>,<span class="attr">name</span>:<span class="string">'zhaoliu'</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">      morestu(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> state.student.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age&gt;<span class="number">20</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>-------年龄大于20岁的人-------<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.morestu&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  上述代码中，在getters声明了名字为 morestu 的方法，默认参数是state，在该方法中通过 state.student 获取到学生的对象，然后通过filter对年龄大于20岁的学生进行筛选，最后再App.vue页面中引用该方法，具体效果图如下：</p>
<p> <img src="https://img-blog.csdnimg.cn/20200516160209794.png" alt="img"> </p>
<h5 id="3-参数"><a href="#3-参数" class="headerlink" title="3.参数"></a>3.参数</h5><p>getters除了可以传递默认的state参数之外，还可以传递getters参数。比如下面的例子：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      student:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">100</span>,<span class="attr">name</span>:<span class="string">'zhangsan'</span>,<span class="attr">age</span>:<span class="number">21</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">200</span>,<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">300</span>,<span class="attr">name</span>:<span class="string">'wangwu'</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">400</span>,<span class="attr">name</span>:<span class="string">'zhaoliu'</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;</span><br><span class="line">      morestu(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> state.student.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age&gt;<span class="number">20</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      morestuLength(state,getters)&#123;</span><br><span class="line">        <span class="keyword">return</span> getters.morestu.length</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  上述代码中，我们希望在知道了年龄大于20岁的学生之后再求出年龄大于20岁的学生的人数，只要在上述的基础上添加length方法即可。<br>  在morestu方法中，我们求出了年龄大于20岁的学生，因此我们可以在morestuLength 求年龄大于20岁的个数的方法中添加参数getters，然后再通过 getters.morestu.length 求年龄大于20岁的个数。</p>
<h5 id="4-函数返回值"><a href="#4-函数返回值" class="headerlink" title="4.函数返回值"></a>4.函数返回值</h5><p>  上面中，我们返回了20岁年龄的人呢，这个20 岁是固定的，那我们能否动态的决定年龄大于某个值呢，其实是可以的，只要<strong>将getters的返回值变成一个函数即可</strong>。比如：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      student:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">100</span>,<span class="attr">name</span>:<span class="string">'zhangsan'</span>,<span class="attr">age</span>:<span class="number">21</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">200</span>,<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">300</span>,<span class="attr">name</span>:<span class="string">'wangwu'</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">400</span>,<span class="attr">name</span>:<span class="string">'zhaoliu'</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">    getters:&#123;</span><br><span class="line">      moreAgeStu(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">age</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> state.student.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age&gt;age)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>-------年龄大于age的人-------<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.moreAgeStu(17)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们希望返回的年龄是根据用户传递的参数进行筛选的。<br>  上述代码中，将getters的返回值变成一个带有age参数的函数，然后根据用户在调用函数时传入的age值进行筛选，比如本例中就筛选出年龄17岁的人。</p>
<p>总结如下：<br> <strong>1.使用场景</strong><br>  当一些数据需要经过变化的时候可以使用getters来处理变化，然后使别的组件在用到该数据时，这个数据是经过变过后得到的结果<br> <strong>2.用法</strong><br> 一般通过声明方法来使用，默认的参数是state<br> <strong>3.方法的参数</strong><br>  除了默认的state参数，还可以传入getters，传入的getters参数其实就是Vuex中的getters，通过这个参数可以调用getters已经声明好的了方法，比如在morestuLength中调用了morestu方法<br> <strong>4.返回值</strong><br>  除了可以直接返回具体的数值之外，还可以返回一个函数，返回函数的情况一般用在需要根据用户的参数进行某些判断的场景。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex的mutations</title>
    <url>/2020/03/17/Vuex%E7%9A%84mutations/</url>
    <content><![CDATA[<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><h5 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h5><p>  <strong>Vuex的store状态的更新唯一方式：提交Mutation</strong>。也就是我们前面提到过的，必须经过 state –&gt; Vuex –&gt; Action –&gt; Mutations 这个路径修改state的状态。</p>
<a id="more"></a>

<h5 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h5><p>mutations主要由两部分组成：<strong>事件类型和回调函数</strong>，具体的可以参考下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      counter:<span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">      increase(state)&#123;</span><br><span class="line">        state.counter++</span><br><span class="line">      &#125;,</span><br><span class="line">      decrease(state)&#123;</span><br><span class="line">        state.counter--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  在上述的代码中，increase和decrease是事件类型，(state){state.counter++} 这部分是回调函数。</p>
<h5 id="3-定义的方式"><a href="#3-定义的方式" class="headerlink" title="3.定义的方式"></a>3.定义的方式</h5><p>定义的方式很简单，就是<strong>事件类型+回调函数</strong>，具体查看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      counter:<span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">      increase(state)&#123;</span><br><span class="line">        state.counter++</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  上述代码中，定义的事件类型为increate，当执行该事件类型时，就会调用回调函数，执行对counter++的操作。<br>  此外，如果想要通过mutations<strong>更新某些数据</strong>，可以使用<strong>commit方法</strong>，commit方法中传入的数据是事件类型。具体代码如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      counter:<span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">     increase:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.$store.commit(<span class="string">'increate'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h1 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h1><h5 id="1-传递变量"><a href="#1-传递变量" class="headerlink" title="1.传递变量"></a>1.传递变量</h5><p>  前面我们已经会通过调用increate函数对counter进行简单的加1操作，如果这个时候我们不再对counter进行简单的加1操作，而是加5甚至是加10，这个时候该怎么办呢？<br> 很简单，只需要传递多一个参数即可，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      counter:<span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">     increateCounter(state,count)&#123;</span><br><span class="line">        state.counter += count</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  在mutation中，声明increateCounter事件类型，然后回调函数主要是对counter做加上count的操作。在App.vue页面中调用该方法的代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addcounter"</span> &gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"deccounter"</span> &gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addCount(5)"</span> &gt;</span>+5<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hellovue</span>&gt;</span><span class="tag">&lt;/<span class="name">hellovue</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> hellovue <span class="keyword">from</span> <span class="string">'./components/HelloWorld.vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  components:&#123;</span><br><span class="line">    hellovue</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    addcounter()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.commit(<span class="string">'increase'</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    deccounter()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.commit(<span class="string">'decrease'</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    addCount(count)&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.commit(<span class="string">'increateCounter'</span>,count)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            message:<span class="string">"我是组件1"</span>,</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  在methods方法中，对addCount点击事件的处理，主要是通过commit方法调用了Vuex中mutation声明的increateCounter，然后传递count作为参数，在本例中，参数count = 5，所以点击一次，counter的数值就会增加5，具体效果图如下所示：</p>
<p> <img src="https://img-blog.csdnimg.cn/20200516160947323.png" alt="img"> </p>
<h5 id="2-传递对象"><a href="#2-传递对象" class="headerlink" title="2.传递对象"></a>2.传递对象</h5><p>具体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      counter:<span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">     increateStu(state,stu)&#123;</span><br><span class="line">        state.student.push(stu)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述代码中，将stu参数添加到student对象中，在App.vue中调用该方法的代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"addStu"</span>&gt;</span>添加学生<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hellovue</span>&gt;</span><span class="tag">&lt;/<span class="name">hellovue</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> hellovue <span class="keyword">from</span> <span class="string">'./components/HelloWorld.vue'</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  components:&#123;</span><br><span class="line">    hellovue</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line"> addStu()&#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">const</span> stu = &#123;id:<span class="number">500</span>,name:<span class="string">'xiaoqi'</span>,age:<span class="number">30</span>&#125;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$store.commit(<span class="string">'increateStu'</span>,stu)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    data()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">            message:<span class="string">"我是组件1"</span>,</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当点击了“添加学生”按钮之后，就会将stu对象中的数据添加到student对象中，具体效果如下：</p>
<p> <img src="https://img-blog.csdnimg.cn/20200516161129941.png" alt="img"> </p>
<p>以上便是mutation中有关传递参数的内容。</p>
<h1 id="提交风格"><a href="#提交风格" class="headerlink" title="提交风格"></a>提交风格</h1><h5 id="1-commit"><a href="#1-commit" class="headerlink" title="1.commit"></a>1.commit</h5><p>这是最简单的提交方式</p>
<h5 id="2-type"><a href="#2-type" class="headerlink" title="2.type"></a>2.type</h5><p>  这种风格的提交就是commit中提交的是一个对象，然后在type中传入具体要传入的数据，比如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//App.vue</span></span><br><span class="line">addCount(count)&#123;</span><br><span class="line">    <span class="comment">// 第一种提风格:commit</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'increateCounter'</span>,count) </span><br><span class="line">    <span class="comment">//第二种提交风格</span></span><br><span class="line">    <span class="keyword">this</span>.$store.commit(&#123;</span><br><span class="line">      type:<span class="string">'increateCounter'</span>,</span><br><span class="line">       count</span><br><span class="line">      &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> store = new Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">      counter:<span class="number">100</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations:&#123;</span><br><span class="line">      <span class="comment">// 提交风格</span></span><br><span class="line">      increateCounter(state,payload)&#123;</span><br><span class="line">        state.counter += payload.count</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>  上述代码中，commit提交的是一个对象，然后在对象中有一个type类型，type后面填写事件类型，比如本例子中的increateCounter。<br>  值得注意的是参数问题。在第一种提交风格中，count就是一个简简单单的数值，但是在第二中风格中，<strong>count是一个对象</strong>，所以我们需要通过 <strong>对象.属性名</strong>来获取具体的变量，比如本例中的 payload.count 就是获得count变量</p>
<h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><h5 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h5><p>响应式就是当数据发生改变的时候，页面中用到该数据的地方也会发生改变。<br>  当我们已经在store对象中定义某些属性时，属性就会被加入到响应式系统中，该系统就会监听属性是否发生变化，如果属性发生变化，就会通知界面中所有用到该属性的地方发生变化，这就是响应式的基本原理。<br>  简单的说就是<strong>预先在store对象定义的属性是被加入到响应式系统中的，只有加入到响应式系统中的属性才会发生响应式的变化。</strong></p>
<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a><strong>set方法</strong></h3><p>  set方法很简单，就是将新增加的属性添加到响应式系统中，这样新增加的属性也可以是响应式的，具体代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line">      changeInfo(state)&#123;</span><br><span class="line">            Vue.<span class="keyword">set</span>(state.info,<span class="string">'address'</span>,<span class="string">'China'</span>)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>  该方法第一个参数是要修改的对象名，第二个参数是要增加是属性名，第三个参数是新增加属性的值。比如本例中为inoffensive对象新增加数值是“China”的address属性。</p>
<h3 id="delete方法"><a href="#delete方法" class="headerlink" title="delete方法"></a>delete方法</h3><p> 很简单，通过 Vue.delete删除，具体查看下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line">      changeInfo(state)&#123;</span><br><span class="line">            Vue.<span class="built_in">delete</span>(state.info,<span class="string">'age'</span>)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>async和await</title>
    <url>/2020/03/20/async%E5%92%8Cawait/</url>
    <content><![CDATA[<blockquote>
<ol>
<li>await后面接一个会return new promise的函数并执行它</li>
<li>await只能放在async函数里</li>
</ol>
</blockquote>
<a id="more"></a>

<ul>
<li>使用async和await获取成功的结果</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 摇色子(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sino = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">6</span> +<span class="number">1</span>)</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(sino)</span><br><span class="line">        &#125;,<span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n =<span class="keyword">await</span> 摇色子()</span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>上面这段代码async中使<code>await 摇色子()</code>先执行，等到三秒后执行完再把得到的结果赋值给左边的n，也就是说test函数需要三秒钟才执行完成，所以test函数是异步的，因此前面必须写async</p>
<ul>
<li>获取失败的结果</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 摇色子(<span class="params">猜测</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sino = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">6</span> +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(sino &gt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(猜测 === <span class="string">'大'</span>)&#123;</span><br><span class="line">                resolve(sino)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                reject(sino)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(猜测 === <span class="string">'大'</span>)&#123;</span><br><span class="line">                reject(sino)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resolve(sino)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(sino)</span><br><span class="line">        &#125;,<span class="number">300</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//把await及获取它的值的操作放在try里</span></span><br><span class="line">        <span class="keyword">let</span> n =<span class="keyword">await</span> 摇色子(<span class="string">'大'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'赢了'</span> + n)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">      <span class="comment">//失败的操作放在catch里</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'输了'</span> + error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>把await和成功后的操作放到try里，失败的放在catch</p>
<ul>
<li>为什么要用await<br> 为了使我们的异步代码，更像同步的代码</li>
<li>有多个promise，怎么拿到所有的promise都结束后的结果<br> 比如有两个色子，我想得到这两个色子的点数</li>
</ul>
<ol>
<li>使用promise</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function 摇色子(猜测)&#123;</span><br><span class="line">    return new Promise((resolve, reject)&#x3D;&gt;&#123;</span><br><span class="line">        let sino &#x3D; parseInt(Math.random() * 6 +1)</span><br><span class="line">        if(sino &gt; 3)&#123;</span><br><span class="line">            if(猜测 &#x3D;&#x3D;&#x3D; &#39;大&#39;)&#123;</span><br><span class="line">                resolve(sino)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                console.log(&#39;error&#39;)</span><br><span class="line">                reject(sino)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(猜测 &#x3D;&#x3D;&#x3D; &#39;大&#39;)&#123;</span><br><span class="line">                console.log(&#39;error&#39;)</span><br><span class="line">                reject(sino)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resolve(sino)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            resolve(sino)</span><br><span class="line">        &#125;,300)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">Promise.all([摇色子(&#39;大&#39;),摇色子(&#39;大&#39;)]).then((x)&#x3D;&gt;&#123;console.log(x)&#125;,(y)&#x3D;&gt;&#123;console.log(y)&#125;)</span><br></pre></td></tr></table></figure>

<p>promise.all里面跟一个数组，数组的每一项是一个返回promise的函数调用，then的第一个参数是所有的promise都成功后调用，拿到所有promise的结果是一个数组；第二个参数拿到的是第一个失败的值</p>
<ol>
<li>使用await<br> await是直接获取多个promise的结果的，因为Promise.all()返回的也是一个promise所以如果要使用await拿到多个promise的值，可以直接await Promise.all()</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([摇色子(<span class="string">'大'</span>),摇色子(<span class="string">'大'</span>)])</span><br><span class="line">        <span class="built_in">console</span>.log(n)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(error)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<ul>
<li>async函数会返回一个promise，并且Promise对象的状态值是resolved（成功的）</li>
</ul>
<ol>
<li><p>如果你没有在async函数中写return，那么Promise对象resolve的值就是是undefined</p>
<p><img src="https://img-blog.csdnimg.cn/20200517140238546.png" alt="在这里插入图片描述"> </p>
</li>
<li><p>如果你写了return，那么return的值就会作为你成功的时候传入的值</p>
<p><img src="https://img-blog.csdnimg.cn/20200517140238545.png" alt="img"> </p>
</li>
</ol>
<p><strong>await 等到之后，做了一件什么事情？</strong><br> 那么右侧表达式的结果，就是await要等的东西。<br> 等到之后，对于await来说，分2个情况</p>
<ul>
<li>不是promise对象</li>
<li>是promise对象</li>
</ul>
<blockquote>
<p>如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果。<br> 如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。</p>
</blockquote>
<ul>
<li>如果asycn里的代码都是同步的，那么这个函数被调用就会同步执行</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//b</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果在await后面接的这个promsie都是同步的，后面的promise会同步执行，但是拿到这个值还是得等待（特别注意：如果promise没有一个成功的值传入，对await来说就算是失败了，下面的代码就不会执行），所以不管await后面的代码是同步还是异步，await总是需要时间，从右向左执行，先执行右侧的代码，执行完后，发现有await关键字，于是让出线程，阻塞代码</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> fn()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>这个代码因为fn是属于同步的，所以先打印出1，然后是3，但是因为没有resolve结果，所以await拿不到值，因此不会打印2</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> fn()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>这个代码与前面相比多了个resolve说明promise成功了，所以await能拿到结果，因此就是1 3 2</p>
<h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async  和 await"></a>async  和 await</h3><ul>
<li>async作为一个关键字放到函数前面<ul>
<li>任何一个<code>async</code>函数都会隐式返回一个<code>promise</code></li>
</ul>
</li>
<li><code>await</code>关键字只能在使用<code>async</code>定义的函数中使用<ul>
<li>​    await后面可以直接跟一个 Promise实例对象</li>
<li>​     await函数不能单独使用</li>
</ul>
</li>
<li><strong>async/await 让异步代码看起来、表现起来更像同步代码</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">	# 1.  async 基础用法</span><br><span class="line">   # 1.1 async作为一个关键字放到函数前面</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     # 1.2 await关键字只能在使用async定义的函数中使用      await后面可以直接跟一个 Promise实例对象</span><br><span class="line">     <span class="keyword">var</span> ret = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         resolve(<span class="string">'nihao'</span>)</span><br><span class="line">       &#125;,<span class="number">1000</span>);</span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="comment">// console.log(ret.data)</span></span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line">   &#125;</span><br><span class="line"># 1.3 任何一个async函数都会隐式返回一个promise   我们可以使用then 进行链式编程</span><br><span class="line">   queryData().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(data)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">#2.  async    函数处理多个异步函数</span><br><span class="line">   axios.defaults.baseURL = <span class="string">'http://localhost:3000'</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     # 2.1  添加await之后 当前的await 返回结果之后才会执行后面的代码   </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">var</span> info = <span class="keyword">await</span> axios.get(<span class="string">'async1'</span>);</span><br><span class="line">     #2.2  让异步代码看起来、表现起来更像同步代码</span><br><span class="line">     <span class="keyword">var</span> ret = <span class="keyword">await</span> axios.get(<span class="string">'async2?info='</span> + info.data);</span><br><span class="line">     <span class="keyword">return</span> ret.data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   queryData().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(data)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>/2020/03/20/axios/</url>
    <content><![CDATA[<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><ul>
<li><p>基于promise用于浏览器和node.js的http客户端</p>
</li>
<li><p>支持浏览器和node.js</p>
</li>
<li><p>支持promise</p>
</li>
<li><p>能拦截请求和响应</p>
</li>
<li><p>自动转换JSON数据</p>
</li>
<li><p>能转换请求和响应数据</p>
<a id="more"></a>

</li>
</ul>
<h4 id="axios基础用法"><a href="#axios基础用法" class="headerlink" title="axios基础用法"></a>axios基础用法</h4><ul>
<li>get和 delete请求传递参数<ul>
<li>通过传统的url  以 ? 的形式传递参数</li>
<li>restful 形式传递参数 </li>
<li>通过params  形式传递参数 </li>
</ul>
</li>
<li>post  和 put  请求传递参数<ul>
<li>通过选项传递参数</li>
<li>通过 URLSearchParams  传递参数 </li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">   # 1. 发送get 请求 </span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/adata'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123; </span><br><span class="line">     #  拿到 ret 是一个对象      所有的对象都存在 ret 的data 属性里面</span><br><span class="line">     <span class="comment">// 注意data属性是固定的用法，用于获取后台的实际数据</span></span><br><span class="line">     <span class="comment">// console.log(ret.data)</span></span><br><span class="line">     <span class="built_in">console</span>.log(ret)</span><br><span class="line">   &#125;)</span><br><span class="line"># 2.  get 请求传递参数</span><br><span class="line">   # 2.1  通过传统的url  以 ? 的形式传递参数</span><br><span class="line">axios.get(<span class="string">'http://localhost:3000/axios?id=123'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">   &#125;)</span><br><span class="line">   # 2.2  restful 形式传递参数 </span><br><span class="line">   axios.get(<span class="string">'http://localhost:3000/axios/123'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">   &#125;)</span><br><span class="line"># 2.3  通过params  形式传递参数 </span><br><span class="line">   axios.get(<span class="string">'http://localhost:3000/axios'</span>, &#123;</span><br><span class="line">     params: &#123;</span><br><span class="line">       id: <span class="number">789</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">   &#125;)</span><br><span class="line">#3 axios delete 请求传参     传参的形式和 get 请求一样</span><br><span class="line">   axios.delete(<span class="string">'http://localhost:3000/axios'</span>, &#123;</span><br><span class="line">     params: &#123;</span><br><span class="line">       id: <span class="number">111</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line"># 4  axios 的 post 请求</span><br><span class="line">   # 4.1  通过选项传递参数</span><br><span class="line">   axios.post(<span class="string">'http://localhost:3000/axios'</span>, &#123;</span><br><span class="line">     uname: <span class="string">'lisi'</span>,</span><br><span class="line">     pwd: <span class="number">123</span></span><br><span class="line">   &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">   &#125;)</span><br><span class="line"># 4.2  通过 URLSearchParams  传递参数 </span><br><span class="line">   <span class="keyword">var</span> params = <span class="keyword">new</span> URLSearchParams();</span><br><span class="line">   params.append(<span class="string">'uname'</span>, <span class="string">'zhangsan'</span>);</span><br><span class="line">   params.append(<span class="string">'pwd'</span>, <span class="string">'111'</span>);</span><br><span class="line">   axios.post(<span class="string">'http://localhost:3000/axios'</span>, params).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">	#5  axios put 请求传参   和 post 请求一样 </span><br><span class="line">   axios.put(<span class="string">'http://localhost:3000/axios/123'</span>, &#123;</span><br><span class="line">     uname: <span class="string">'lisi'</span>,</span><br><span class="line">     pwd: <span class="number">123</span></span><br><span class="line">   &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(ret.data)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="axios-全局配置"><a href="#axios-全局配置" class="headerlink" title="axios 全局配置"></a>axios 全局配置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#  配置公共的请求头 </span><br><span class="line">axios.defaults.baseURL = <span class="string">'https://api.example.com'</span>;</span><br><span class="line">#  配置 超时时间</span><br><span class="line">axios.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line">#  配置公共的请求头</span><br><span class="line">axios.defaults.headers.common[<span class="string">'Authorization'</span>] = AUTH_TOKEN;</span><br><span class="line"># 配置公共的 post 的 Content-Type</span><br><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h4><ul>
<li>请求拦截器<ul>
<li>请求拦截器的作用是在请求发送前进行一些操作<ul>
<li>例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易</li>
</ul>
</li>
</ul>
</li>
<li>响应拦截器<ul>
<li>响应拦截器的作用是在接收到响应后进行一些操作<ul>
<li>例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 1. 请求拦截器 </span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(config.url)</span><br><span class="line">     # 1.1  任何请求都会经过这一步   在发送请求之前做些什么   </span><br><span class="line">     config.headers.mytoken = <span class="string">'nihao'</span>;</span><br><span class="line">     # 1.2  这里一定要return   否则配置不成功  </span><br><span class="line">     <span class="keyword">return</span> config;</span><br><span class="line">   &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      #1.3 对请求错误做点什么    </span><br><span class="line">     <span class="built_in">console</span>.log(err)</span><br><span class="line">   &#125;)</span><br><span class="line">#2. 响应拦截器 </span><br><span class="line">   axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">     #2.1  在接收响应做些什么  </span><br><span class="line">     <span class="keyword">var</span> data = res.data;</span><br><span class="line">     <span class="keyword">return</span> data;</span><br><span class="line">   &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">     #2.2 对响应错误做点什么  </span><br><span class="line">     <span class="built_in">console</span>.log(err)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令清单</title>
    <url>/2020/03/23/git%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="常用-Git-命令清单"><a href="#常用-Git-命令清单" class="headerlink" title="常用 Git 命令清单"></a>常用 Git 命令清单</h1><p>我每天使用 Git ，但是很多命令记不住。</p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<a id="more"></a>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt="img"></p>
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个可供发布的压缩包</span></span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="参考《阮一峰的网络日志》"><a href="#参考《阮一峰的网络日志》" class="headerlink" title="参考《阮一峰的网络日志》"></a>参考《阮一峰的网络日志》</h3>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>json和对象增强写法和箭头函数</title>
    <url>/2020/02/21/json%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%A2%9E%E5%BC%BA%E5%86%99%E6%B3%95%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6中新增的定义函数的方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">() =&gt; &#123;&#125; <span class="comment">//()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体</span></span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;<span class="comment">//代表把一个函数赋值给fn</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> num1 + num2; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//es6写法</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br></pre></td></tr></table></figure>

<p>如果形参只有一个，可以省略小括号</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//es6写法</span></span><br><span class="line"> <span class="keyword">const</span> fn = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br></pre></td></tr></table></figure>

<p>箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'张三'</span>&#125; </span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//this 指向 是obj对象</span></span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">         <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象</span></span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">const</span> resFn = fn.call(obj); </span><br><span class="line"> resFn();</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁</li>
<li>箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题</li>
</ul>
<h3 id="字面量增强写法"><a href="#字面量增强写法" class="headerlink" title="字面量增强写法"></a>字面量增强写法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">12</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">'aaaa'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: a,</span><br><span class="line">    b: b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在ES6当中 key和value的值相等所以可以简写为</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a,</span><br><span class="line">    b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ES5对象里的方法是这样定义的</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">12</span></span><br><span class="line">    sun: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6可以这样书写</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    a: <span class="number">12</span></span><br><span class="line">    sun()&#123;</span><br><span class="line">        <span class="keyword">this</span>.a++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON: JavaScript Object Notation(JavaScript 对象表示法)</p>
<p>JSON 是存储和交换文本信息的语法。类似 XML。</p>
<p>JSON 比 XML 更小、更快，更易解析。</p>
<p>对象语法<br>实例：</p>
<p>{ “name”:“runoob”, “alexa”:10000, “site”:null }<br>JSON 对象使用在大括号({})中书写。</p>
<p>对象可以包含多个 key/value（键/值）对。</p>
<p>key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。</p>
<p>key 和 value 中使用冒号(:)分割。</p>
<p>每个 key/value 对使用逗号(,)分割。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">“sites”: [</span><br><span class="line">&#123; “name”:“菜鸟教程” , “url”:“www.runoob.com” &#125;,</span><br><span class="line">&#123; “name”:“google” , “url”:“www.google.com” &#125;,</span><br><span class="line">&#123; “name”:“微博” , “url”:“www.weibo.com” &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h2><p>JSON 通常用于与服务端交换数据。</p>
<p>在接收服务器数据时一般是字符串。</p>
<p>我们可以使用 JSON.parse() 方法将数据转换为 JavaScript 对象。</p>
<h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><p>JSON 通常用于与服务端交换数据。<br>在向服务器发送数据时一般是字符串。<br>我们可以使用 JSON.stringify() 方法将 JavaScript 对象转换为字符串。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>hash和history模式的区别</title>
    <url>/2020/03/12/hash%E5%92%8Chistory%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="hash和history两种模式的区别"><a href="#hash和history两种模式的区别" class="headerlink" title="hash和history两种模式的区别"></a>hash和history两种模式的区别</h2><blockquote>
<p>众所周知，vue-router有两种模式，hash模式和history模式，这里来谈谈两者的区别。</p>
<a id="more"></a>
</blockquote>
<h2 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h2><p>hash模式背后的原理是<code>onhashchange</code>事件,可以在window对象上监听这个事件:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(event.oldURL, event.newURL);</span><br><span class="line">     <span class="keyword">let</span> hash = location.hash.slice(<span class="number">1</span>); </span><br><span class="line">     <span class="built_in">document</span>.body.style.color = hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码可以通过改变hash来改变页面字体颜色，虽然没什么用，但是一定程度上说明了原理。 更关键的一点是，因为hash发生变化的url都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用了，同时点击后退时，页面字体颜色也会发生变化。这样一来，尽管浏览器没有请求服务器，但是页面状态和url一一关联起来，后来人们给它起了一个霸气的名字叫前端路由，成为了单页应用标配。</p>
<h2 id="history路由-放在服务器环境下测试"><a href="#history路由-放在服务器环境下测试" class="headerlink" title="history路由(放在服务器环境下测试)"></a>history路由(放在服务器环境下测试)</h2><p>随着history api的到来，前端路由开始进化了,前面的hashchange，你只能改变#后面的url片段，而history api则给了前端完全的自由</p>
<p>history api可以分为两大部分，切换和修改，参考MDN，切换历史状态包括<code>back</code>、<code>forward</code>、<code>go</code> 三个方法，对应浏览器的前进，后退，跳转操作，有同学说了，(谷歌)浏览器只有前进和后退，没有跳转，嗯，在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转(也许叫跳更合适)：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">history.<span class="keyword">go</span>(<span class="number">-2</span>);<span class="comment">//后退两次</span></span><br><span class="line">history.<span class="keyword">go</span>(<span class="number">2</span>);<span class="comment">//前进两次</span></span><br><span class="line">history.back(); <span class="comment">//后退</span></span><br><span class="line">hsitory.forward(); <span class="comment">//前进</span></span><br></pre></td></tr></table></figure>

<h3 id="修改历史状态包括了pushState-replaceState"><a href="#修改历史状态包括了pushState-replaceState" class="headerlink" title="修改历史状态包括了pushState,replaceState"></a>修改历史状态包括了<code>pushState</code>,<code>replaceState</code></h3><p>两个方法,这两个方法接收三个参数:<code>stateObj</code>,<code>title</code>,<code>url</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">history.pushState(&#123;<span class="attr">color</span>:<span class="string">'red'</span>&#125;, <span class="string">'red'</span>, <span class="string">'red'</span>)</span><br><span class="line">history.back();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     history.forward();</span><br><span class="line"> &#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(event.state)</span><br><span class="line">     <span class="keyword">if</span>(event.state &amp;&amp; event.state.color === <span class="string">'red'</span>)&#123;</span><br><span class="line">           <span class="built_in">document</span>.body.style.color = <span class="string">'red'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>pushstate</code>把页面的状态保存在state对象中，当页面的url再变回这个url时，可以通过<code>event.state</code>取到这个<code>state</code>对象，从而可以对页面状态进行还原，这里的页面状态就是页面字体颜色，其实滚动条的位置，阅读进度，组件的开关的这些页面状态都可以存储到state的里面。</p>
<h3 id="history模式的问题"><a href="#history模式的问题" class="headerlink" title="history模式的问题"></a>history模式的问题</h3><p>通过history api，我们丢掉了丑陋的#，但是它也有个问题：不怕前进，不怕后退，就怕<strong>刷新</strong>，<strong>f5</strong>，（如果后端没有准备的话）,因为刷新是实实在在地去请求服务器的,不玩虚的。 在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题.但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。</p>
<h4 id="如何实现修改URL而不刷新页面"><a href="#如何实现修改URL而不刷新页面" class="headerlink" title="如何实现修改URL而不刷新页面"></a>如何实现修改URL而不刷新页面</h4><p><strong>① 修改URL的hash</strong><br> 在控制台中输入命令： location.hash=”xxx”<br>  如果页面的URL发生改变，就会向服务器发送请求，请求的资源我们可以在Network查看。所以演示的步骤如下：在控制台输入  location.hash=”aaa” –&gt;观察浏览器的地址栏是否改变 –&gt; 查看Network 是否有新资源。<br>  <img src="https://img-blog.csdnimg.cn/2020051516195330.png" alt="在这里插入图片描述"> </p>
<p>在控制台输入  location.hash=”aaa”</p>
<p> <img src="https://img-blog.csdnimg.cn/2020051516195333.png" alt="在这里插入图片描述"> </p>
<p><strong>② html5 的pushState</strong></p>
<p>这是第二种修改URL而不刷新页面的方法，用法如下： history.pushState({…},’xxx’,’URL’)  。第一个参数是对象，第二个参数是title，第三个参数是URL</p>
<p> <img src="https://img-blog.csdnimg.cn/20200515162111161.png" alt="在这里插入图片描述"> </p>
<p> <img src="https://img-blog.csdnimg.cn/2020051516195332.png" alt="在这里插入图片描述"> </p>
<p>  history.pushState指令的原理和栈结构相似。先进后出，当在控制台输入多个history.pushState指令时，URL只会显示最后一条指令的URL。</p>
<p><strong>③ html5 的replaceState</strong><br> 同样的，和pushState工作的基本原理相似，但是也有不同：<br>  pushState是一个类似栈的结构，会<strong>保存历史记录</strong>，所以可以返回上一次访问过的页面；<br>  而replaceState 是直接用当前的URL替代了上一个URL，所以<strong>不能够返回上一次访问过的页面</strong>。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Router</tag>
      </tags>
  </entry>
</search>
